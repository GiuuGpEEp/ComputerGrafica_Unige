# CMake SFML Project Template

This repository template should allow for a fast and hassle-free kick start of your next SFML project using CMake.
Thanks to [GitHub's nature of templates](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template), you can fork this repository without inheriting its Git history.

The template starts out very basic, but might receive additional features over time:

- Basic CMake script to build your project and link SFML on any operating system
- Basic [GitHub Actions](https://github.com/features/actions) script for all major platforms

## How to Use

1. Install [Git](https://git-scm.com/downloads) and [CMake](https://cmake.org/download/). Use your system's package manager if available.
2. Follow [GitHub's instructions](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template) for how to use their project template feature to create your own project. If you don't want to use GitHub, see the section below.
3. Clone your new GitHub repo and open the repo in your text editor of choice.
4. Open [CMakeLists.txt](CMakeLists.txt). Rename the project and the target name of the executable to whatever name you want. Make sure to change all occurrences.
5. If you want to add or remove any .cpp files, change the source files listed in the `add_executable` call in CMakeLists.txt to match the source files your project requires. If you plan on keeping the default main.cpp file then no changes are required.
6. If your code uses the Audio or Network modules then add `sfml-audio` or `sfml-network` to the `target_link_libraries` call alongside the existing `sfml-graphics` library that is being linked.
7. If you use Linux, install SFML's dependencies using your system package manager. On Ubuntu and other Debian-based distributions you can use the following commands:
   ```
   sudo apt update
   sudo apt install \
       libxrandr-dev \
       libxcursor-dev \
       libxi-dev \
       libudev-dev \
       libfreetype-dev \
       libflac-dev \
       libvorbis-dev \
       libgl1-mesa-dev \
       libegl1-mesa-dev \
       libfreetype-dev
   ```
8. Configure and build your project. Most popular IDEs support CMake projects with very little effort on your part.

   - [VS Code](https://code.visualstudio.com) via the [CMake extension](https://code.visualstudio.com/docs/cpp/cmake-linux)
   - [Visual Studio](https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170)
   - [CLion](https://www.jetbrains.com/clion/features/cmake-support.html)
   - [Qt Creator](https://doc.qt.io/qtcreator/creator-project-cmake.html)

   Using CMake from the command line is straightforward as well.
   Be sure to run these commands in the root directory of the project you just created.

   ```
   cmake -B build
   cmake --build build
   ```

9. Enjoy!

## Upgrading SFML

SFML is found via CMake's [FetchContent](https://cmake.org/cmake/help/latest/module/FetchContent.html) module.
FetchContent automatically downloads SFML from GitHub and builds it alongside your own code.
Beyond the convenience of not having to install SFML yourself, this ensures ABI compatibility and simplifies things like specifying static versus shared libraries.

Modifying what version of SFML you want is as easy as changing the `GIT_TAG` argument.
Currently it uses SFML 3 via the `3.0.0` tag.

## But I want to...

Modify CMake options by adding them as configuration parameters (with a `-D` flag) or by modifying the contents of CMakeCache.txt and rebuilding.

### Not use GitHub

You can use this project without a GitHub account by [downloading the contents](https://github.com/SFML/cmake-sfml-project/archive/refs/heads/master.zip) of the repository as a ZIP archive and unpacking it locally.
This approach also avoids using Git entirely if you would prefer to not do that.

### Change Compilers

See the variety of [`CMAKE_<LANG>_COMPILER`](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html) options.
In particular you'll want to modify `CMAKE_CXX_COMPILER` to point to the C++ compiler you wish to use.

### Change Compiler Optimizations

CMake abstracts away specific optimizer flags through the [`CMAKE_BUILD_TYPE`](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html) option.
By default this project recommends `Release` builds which enable optimizations.
Other build types include `Debug` builds which enable debug symbols but disable optimizations.
If you're using a multi-configuration generator (as is often the case on Windows), you can modify the [`CMAKE_CONFIGURATION_TYPES`](https://cmake.org/cmake/help/latest/variable/CMAKE_CONFIGURATION_TYPES.html#variable:CMAKE_CONFIGURATION_TYPES) option.

### Change Generators

While CMake will attempt to pick a suitable default generator, some systems offer a number of generators to choose from.
Ubuntu, for example, offers Makefiles and Ninja as two potential options.
For a list of generators, click [here](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html).
To modify the generator you're using you must reconfigure your project providing a `-G` flag with a value corresponding to the generator you want.
You can't simply modify an entry in the CMakeCache.txt file unlike the above options.
Then you may rebuild your project with this new generator.

## More Reading

Here are some useful resources if you want to learn more about CMake:

- [Official CMake Tutorial](https://cmake.org/cmake/help/latest/guide/tutorial/)
- [How to Use CMake Without the Agonizing Pain - Part 1](https://alexreinking.com/blog/how-to-use-cmake-without-the-agonizing-pain-part-1.html)
- [How to Use CMake Without the Agonizing Pain - Part 2](https://alexreinking.com/blog/how-to-use-cmake-without-the-agonizing-pain-part-2.html)
- [Better CMake YouTube series by Jefferon Amstutz](https://www.youtube.com/playlist?list=PL8i3OhJb4FNV10aIZ8oF0AA46HgA2ed8g)

## License

The source code is dual licensed under Public Domain and MIT -- choose whichever you prefer.

# Preview del progetto

Il progetto ultimato è in: Progetto/ConsegnaFinale. Questa sezione guida rapidamente alla struttura e a come orientarsi nel codice finale.

Struttura di ConsegnaFinale
- main.cpp
  - Entry point dell’app.  
  - Inizializza finestra SFML, TextureManager, ResourceManager, Field, overlay (Extra/Graveyard), controller (Draw/Discard), AI P2 e tutto lo stato UI.  
  - Avvia e anima le schermate: Start → Home → FieldLoading → Playing.  
  - Gestisce il loop principale: eventi, update (pescate, animazioni, AI), rendering e HUD.
- HomePage/
  - HomePage.h/.cpp: schermata iniziale con pulsanti “Gioca” e selezione mazzo, visualizzazione nome deck selezionato.
  - DeckSelectionScreen: UI per scegliere il mazzo (Blue-Eyes, ecc.) con effetti di fade.
- GameWiring/
  - GameWiring.h/.cpp: factory per creare il Game e collegare risorse; setupAppHandlers per sottoscrivere gli handler app–engine (sync grafica, prompt, overlay).
- InputController/
  - InputController.h/.cpp: centralizza l’handling degli input (mouse/tastiera) e le azioni contestuali (drag dalla mano, conferme overlay, chiusura popup, ecc.).
  - Espone un Context con callback del main (resetMatch, sync zone, conferme prompt).
- GameLogic/
  - Game/: motore di gioco (giocatori, turni/fasi, regole di evocazione, cimitero, catene, eventi, pending per i prompt).
  - Player/: stato mano, LP, zone Mostri/Magie-Trappole, Campo.
  - TurnManager/: gestione turno, fasi, avanzamento.
  - Events/: EventDispatcher e tipi di eventi emessi/consumati (pescate, evocazioni, attacchi, fine fase, ecc.).
  - Effects/: sistema effetti (registrazione e risoluzione), inclusi gli effetti specifici delle carte principali (es. Saggio, Fanciulla, Spirito del Bianco, Pietra Bianca).
  - DrawController/, DiscardController/: animazioni e flusso di pescata/scarto sincronizzati col motore.
  - AI/: AIController del Player 2 (scelte automatiche/heuristiche e auto-pass su catene).
- Deck/
  - Gestione mazzo, extra deck, animazioni di shuffle e disegno dei “pile” sul campo.
- Field/
  - Field.h/.cpp: layout del campo (slot Mostri/M/T/Campo/Deck/Cimitero/Extra) e animazione di transizione FieldLoading→FieldVisible.
- FieldLoadingAnimation/
  - Animazione di ingresso dal menu al campo di gioco.
- Utils/
  - RenderUtils: funzioni di disegno (mani, zone, overlay, HUD, prompt).
  - AppConfig: configurazioni UI/Timing/percorsi, mapping texture (TextureKey), dimensioni carte/slot.
  - auxFunc e utility varie (font, calcoli posizioni, ecc.).
  - ResourceManager: caricamento risorse (carte, texture, deck) da asset/JSON.
- Overlay (Extra/Graveyard)
  - ExtraDeckOverlay, GraveyardOverlay: sovrapposizioni modali per consultare Extra e Cimitero, dettagli scorrevoli e selezioni quando richieste.
- Risorse (texture/font)
  - Gestite tramite TextureManager e AppConfig::buildTextureMap; le texture sono referenziate per chiave (CardBack, FieldBackground, icone, ecc.).

Flusso e layering
- Presentazione (main + Field + RenderUtils + Overlay): disegna stato e UI, chiama GameWiring per collegare logica ed eventi.
- Controller (InputController, Draw/DiscardController): traduce input/animazioni in chiamate al Game e richieste di prompt.
- Motore (GameLogic/Game + Effects + Events): regole, fasi, catene, effetti, pending per i prompt (selezioni da deck/cimitero, scelta M/T avversarie, SS position, ecc.).
- AI (AIController): gioca per P2; auto-risolve scelte quando l’owner è l’avversario (nessun prompt).

Prompt e UX principali
- Selezione da Deck/Cimitero/Scelte speciali: overlay “DeckSend” riusato con titolo contestuale:
  - Melodia/Add: “Scegli un Mostro Drago dal Deck da aggiungere alla mano”
  - Fanciulla/Saggio (SS scelta): “Seleziona mostro da evocare specialmente”
  - Spirito del Bianco (banish M/T avversaria): “Scegli la carta da bandire”
  - Richiamo dal Cimitero: “Scegli il mostro da evocare”
- Prompt di risposta (catene): elenca attivabili (Magie Rapide/Trappole settate, effetti rapidi mostri controllati dal giocatore locale).
- Scelte immediate:
  - Evocazione Speciale: A (Attacco), D (Difesa)
  - Spell/Trap dalla mano: A (Attiva), S (Setta)
  - Mostri dalla mano: E (Evoca), P (Posiziona)
- Navigazione turno/fasi: HUD mostra key-hints (es. N = Next phase, T = End turn).

Comportamenti chiave implementati
- P2 (AI) auto-risolve i prompt: quando l’owner è l’avversario, niente overlay; scelta random coerente con le regole.
- Skip rapido post-Draw: al termine della pescata in Draw Phase (se non ci sono prompt/trigger) il gioco avanza automaticamente alla fase successiva.
- Ripristino robusto della Home: resetMatch e una “safety net” azzerano eventuali modal/overlay residui al ritorno alla Home per evitare input bloccati.

Carte/effects principali (Blue-Eyes)
- Saggio con gli Occhi Blu: attivabile solo in Main1/Main2; P2 auto, P1 con prompt dove richiesto.
- Fanciulla con gli Occhi di Blu: al trigger corretti titoli/prompt; P2 auto, P1 con scelta.
- Drago Spirito del Bianco:
  - On-summon: bandisci 1 Magia/Trappola avversaria (inclusa Magia Terreno). P1 con prompt e titolo dedicato; P2 auto.
  - Effetto rapido (chain/turno avversario): tributare lo Spirito per Evocare Specialmente un “Drago Bianco Occhi Blu” dalla mano; appare nel prompt di risposta quando legale.
- Pietra Bianca degli Antichi: entrambe le copie (di entrambi i giocatori) possono triggerare correttamente in End Phase se mandate al Cimitero in quel turno.

Come eseguire
- Apri la cartella Progetto in VS Code/IDE, builda ed esegui il target basato su ConsegnaFinale (main.cpp).
- In gioco:
  - Seleziona un deck in Home (Deck Selection), poi “Gioca”.
  - Segui le indicazioni HUD per fasi e tasti rapidi; i prompt si aprono automaticamente quando servono.

Suggerimenti di navigazione del codice
- Punto di ingresso: ConsegnaFinale/main.cpp
- Wiring logica/UI: GameWiring/
- Input e interazioni: InputController/
- Motore e regole: GameLogic/Game/, TurnManager/, Events/, Effects/
- Rendering e layout: Field/, Utils/RenderUtils, AppConfig
- Mazzi/animazioni: Deck/
- Overlay: ExtraDeckOverlay, GraveyardOverlay

Note finali
- L’AI del P2 auto-risolve le scelte per non interrompere il flusso col giocatore.
- I prompt mostrano testi e contenuti coerenti al contesto; alcune selezioni riutilizzano lo stesso overlay con titolo/hint variabili.
- Il README interno di ConsegnaFinale contiene note di rilascio e dettagli puntuali
