# Preview del progetto

Il progetto ultimato è in: Progetto/ConsegnaFinale. Questa sezione guida rapidamente 

Struttura di ConsegnaFinale
- main.cpp
  - Entry point dell’app.  
  - Inizializza finestra SFML, TextureManager, ResourceManager, Field, overlay (Extra/Graveyard), controller (Draw/Discard), AI P2 e tutto lo stato UI.  
  - Avvia e anima le schermate: Start → Home → FieldLoading → Playing.  
  - Gestisce il loop principale: eventi, update (pescate, animazioni, AI), rendering e HUD.
- HomePage/
  - HomePage.h/.cpp: schermata iniziale con pulsanti “Gioca” e selezione mazzo, visualizzazione nome deck selezionato.
  - DeckSelectionScreen: UI per scegliere il mazzo (Blue-Eyes, ecc.) con effetti di fade.
- GameWiring/
  - GameWiring.h/.cpp: factory per creare il Game e collegare risorse; setupAppHandlers per sottoscrivere gli handler app–engine (sync grafica, prompt, overlay).
- InputController/
  - InputController.h/.cpp: centralizza l’handling degli input (mouse/tastiera) e le azioni contestuali (drag dalla mano, conferme overlay, chiusura popup, ecc.).
  - Espone un Context con callback del main (resetMatch, sync zone, conferme prompt).
- GameLogic/
  - Game/: motore di gioco (giocatori, turni/fasi, regole di evocazione, cimitero, catene, eventi, pending per i prompt).
  - Player/: stato mano, LP, zone Mostri/Magie-Trappole, Campo.
  - TurnManager/: gestione turno, fasi, avanzamento.
  - Events/: EventDispatcher e tipi di eventi emessi/consumati (pescate, evocazioni, attacchi, fine fase, ecc.).
  - Effects/: sistema effetti (registrazione e risoluzione), inclusi gli effetti specifici delle carte principali (es. Saggio, Fanciulla, Spirito del Bianco, Pietra Bianca).
  - DrawController/, DiscardController/: animazioni e flusso di pescata/scarto sincronizzati col motore.
  - AI/: AIController del Player 2 (scelte automatiche/heuristiche e auto-pass su catene).
- Deck/
  - Gestione mazzo, extra deck, animazioni di shuffle e disegno dei “pile” sul campo.
- Field/
  - Field.h/.cpp: layout del campo (slot Mostri/M/T/Campo/Deck/Cimitero/Extra) e animazione di transizione FieldLoading→FieldVisible.
- FieldLoadingAnimation/
  - Animazione di ingresso dal menu al campo di gioco.
- Utils/
  - RenderUtils: funzioni di disegno (mani, zone, overlay, HUD, prompt).
  - AppConfig: configurazioni UI/Timing/percorsi, mapping texture (TextureKey), dimensioni carte/slot.
  - auxFunc e utility varie (font, calcoli posizioni, ecc.).
  - ResourceManager: caricamento risorse (carte, texture, deck) da asset/JSON.
- Overlay (Extra/Graveyard)
  - ExtraDeckOverlay, GraveyardOverlay: sovrapposizioni modali per consultare Extra e Cimitero, dettagli scorrevoli e selezioni quando richieste.
- Risorse (texture/font)
  - Gestite tramite TextureManager e AppConfig::buildTextureMap; le texture sono referenziate per chiave (CardBack, FieldBackground, icone, ecc.).

Flusso e layering
- Presentazione (main + Field + RenderUtils + Overlay): disegna stato e UI, chiama GameWiring per collegare logica ed eventi.
- Controller (InputController, Draw/DiscardController): traduce input/animazioni in chiamate al Game e richieste di prompt.
- Motore (GameLogic/Game + Effects + Events): regole, fasi, catene, effetti, pending per i prompt (selezioni da deck/cimitero, scelta M/T avversarie, SS position, ecc.).
- AI (AIController): gioca per P2; auto-risolve scelte quando l’owner è l’avversario (nessun prompt).

Prompt e UX principali
- Selezione da Deck/Cimitero/Scelte speciali: overlay “DeckSend” riusato con titolo contestuale:
  - Melodia/Add: “Scegli un Mostro Drago dal Deck da aggiungere alla mano”
  - Fanciulla/Saggio (SS scelta): “Seleziona mostro da evocare specialmente”
  - Spirito del Bianco (banish M/T avversaria): “Scegli la carta da bandire”
  - Richiamo dal Cimitero: “Scegli il mostro da evocare”
- Prompt di risposta (catene): elenca attivabili (Magie Rapide/Trappole settate, effetti rapidi mostri controllati dal giocatore locale).
- Scelte immediate:
  - Evocazione Speciale: A (Attacco), D (Difesa)
  - Spell/Trap dalla mano: A (Attiva), S (Setta)
  - Mostri dalla mano: E (Evoca), P (Posiziona)
- Navigazione turno/fasi: HUD mostra key-hints (es. N = Next phase, T = End turn).

Comportamenti chiave implementati
- P2 (AI) auto-risolve i prompt: quando l’owner è l’avversario, niente overlay; scelta random coerente con le regole.
- Skip rapido post-Draw: al termine della pescata in Draw Phase (se non ci sono prompt/trigger) il gioco avanza automaticamente alla fase successiva.
- Ripristino robusto della Home: resetMatch e una “safety net” azzerano eventuali modal/overlay residui al ritorno alla Home per evitare input bloccati.

Carte/effects principali (Blue-Eyes)
- Saggio con gli Occhi Blu: attivabile solo in Main1/Main2; P2 auto, P1 con prompt dove richiesto.
- Fanciulla con gli Occhi di Blu: al trigger corretti titoli/prompt; P2 auto, P1 con scelta.
- Drago Spirito del Bianco:
  - On-summon: bandisci 1 Magia/Trappola avversaria (inclusa Magia Terreno). P1 con prompt e titolo dedicato; P2 auto.
  - Effetto rapido (chain/turno avversario): tributare lo Spirito per Evocare Specialmente un “Drago Bianco Occhi Blu” dalla mano; appare nel prompt di risposta quando legale.
- Pietra Bianca degli Antichi: entrambe le copie (di entrambi i giocatori) possono triggerare correttamente in End Phase se mandate al Cimitero in quel turno.

Come eseguire
- Apri la cartella Progetto in VS Code/IDE, builda ed esegui il target basato su ConsegnaFinale (main.cpp).
- In gioco:
  - Seleziona un deck in Home (Deck Selection), poi “Gioca”.
  - Segui le indicazioni HUD per fasi e tasti rapidi; i prompt si aprono automaticamente quando servono.

Suggerimenti di navigazione del codice
- Punto di ingresso: ConsegnaFinale/main.cpp
- Wiring logica/UI: GameWiring/
- Input e interazioni: InputController/
- Motore e regole: GameLogic/Game/, TurnManager/, Events/, Effects/
- Rendering e layout: Field/, Utils/RenderUtils, AppConfig
- Mazzi/animazioni: Deck/
- Overlay: ExtraDeckOverlay, GraveyardOverlay

Note finali
- L’AI del P2 auto-risolve le scelte per non interrompere il flusso col giocatore.
- I prompt mostrano testi e contenuti coerenti al contesto; alcune selezioni riutilizzano lo stesso overlay con titolo/hint variabili.
- Il README interno di ConsegnaFinale contiene note di rilascio e dettagli puntuali