# Settima Tappa del Progetto

L'obiettivo di questa settima tappa principalmente è quello di rifinire alcune cose della 6.

1. Spostare tutta la logica dell'animazione di pescata all'interno di una classe apposita in modo da ordinare meglio il codice. moveTowards è stata spostata come metodo di un oggetto della classe DrawAnimation
2. Sistemare l'animazione di pescata --> nella tappa precedente ero riuscito a creare con successo un'animazione per la pescata, ma era laggosa e non fatta particolarmente bene; cerco quindi di sistemarla
3. Dopo aver sistemato queste "piccolezze" cerco di andare a costruire una prima forma di drag & drop delle carte in modo da spostarle con successo negli slot corretti.

"Da mettere nella tappa 8"

1. Creazione di più deck preimpostati e scelta
2. Caricamento di texture differenti per diversi tipi di carte --> ora come ora le carte caricano tutte la stessa texture, vorrei differenziare in modo tale da far si che le carte di tipi diversi carichino texture diverse.
3. Creazione di una reale "schermata di intro" con scritta "pressione tasto INVIO"
4. schermata di scelta tra "Gioca" e "Scegli il tuo deck"

Ho quindi leggermente modificato il metodo moveTowards, e cambiata la logica delle animazioni. Al posto che inserirle tutte insieme ne inserisco una per volta e l'altra verrà aggiunta quando la precedente animazione termina. In questo modo al posto di animarle tutte assieme verrà animata solo una carta alla volta. Per far ciò ho creato una coda di carte da pescare. 
Ho quindi creato la classe DrawAnimation che contiene al suo interno il metodo moveTowards modificato e tutto ciò che serve per gestire al meglio l'animazione. 
Ho successivamente cambiato la forma, e alcuni parametri per garantire un movimento fluido: 
ALl'interno della moveTOwards ho aggiunto dei setPosition per settare di volta in volta la posizione e avere un movimento più fluido.
Ho tolto il parametro sf::Vector2f outOfScreenPos e usato direttamente le windowSize.

Dopo aver sistemato questa animazione ho spostato le parti relative al movimento del campo e deck nelle relative classi, in modo da mantenere il codice più ordinato.
**Nota - Modifiche principali all'animazione di pescata**: L'animazione rispetto a prima è stata resa più fluida e veloce. Inoltre quando si passa nella fase in cui la carta si ferma per vederne i dettagli compare anche a lato la finestra con tutti i relativi dettagli della carta. La carta resta ferma per un totale di circa 3/4 secondi, ma se si schiaccia il tasto sinistro del mouse vanno subito in mano.

---

**Dragging**: Inizialmente ho aggiunto unicamente le prime variabili per il dragging: 

- bool isDragging; --> booleano per segnare la fase effettiva di dragging
- std::optional<size_t> draggingCardIndex; --> indice della carta selezionata
- sf::Vector2f dragOffset; --> Offset tra mouse e posizione carta, serve per garantire che la carta segua effettivamente il mouse in modo fluido

Rispetto a prima adesso quando si rileva che il tasto del mouse è schiacciato oltre a mettere a true mousePressed viene messa a true anche la variabile isDragging, e si prepara la carta selezionata. 
Tutto ciò veniva fatto nella parte di gestione eventi, nella parte di logica effettiva invece si va ad aggiornare la posizione della carta durante il dragging.

Tuttavia con questa prima metodologia appena cliccavo una carta quest'ultima entrava subito in "modalità dragging", e quindi veniva subito spostata senza permettermi di vederne i dettagli. Di conseguenza ciò che ho fatto è stato aggiungere una soglia di movimento per lo scatenarsi del dragging effettivo. In questo modo se clicco unicamente su una carta, e muovo il mouse di poco il dragging non si scatenerà.

Per far ciò ho aggiunto il booleano isPotentialDragging che diventa true quando clicco su una carta. Se poi supero la soglia allora questo isPotentialDragging scatenerà il dragging effettivo,

**Funzionamento del Dragging e MouseHover**: Quindi dopo queste versioni, se il mouse si muove sopra una carta ma nessun tasto viene premuto non succede nulla, se invece viene premuto il tasto sinistro le carte su cui il mouse passa mentre questo tasto è premuto si alzeranno. Se la carta viene mossa verso l'alto, superando una certa soglia, allora li partirà il dragging.

---

**Droppable Zone**: Dopo aver implementato con successo il drag, voglio far si che vi siano delle "zone di drop", ovvero gli slot effettivi dove è possibile posare la carta. Se la carta non viene posata in nessuna di queste zone allora deve ritornare in mano. Per questo sistema ho aggiunto una funzione in auxFunc:

- Questa è una funzione optional, quindi può avere un valore o essere nulla, e ci restituisce la posizione dello slot. Viene utilizzata per far si che, se quando lasciamo la carta quest'ultima  è in uno slot valido allora recuperiamo la posizione essatta di quello 

Le modifiche fatte nel main sono unicamente relative alla gestione degli eventi, in particolare parliamo del rilascio della pressione del tasto del mouse

**Modifica della classe Card** --> Aggiunta del getType per trovare il tipo della carta. Fino ad ora non avevo infatti ancora impostato un tipo effettivo alle carte. Per far ciò ho spostato l'enum class Type dal file slot.h all'interno della cartella resources
