## Tappa 16 — Implementazione degli effetti mancanti

Di seguito gli effetti implementati/rifiniti e, per ciascuno, la descrizione funzionale e le modifiche ai file necessarie per ottenerne il comportamento.

### Effetti implementati/rifiniti 

- **Saggio con (gli) Occhi di Blu**
	- Cosa fa (tutti i flussi sono a scelta P1; P2 è auto‑risolto dall'AI)
		- Prompt A/E/P quando trascini il Saggio dalla mano sopra la zona Mostri:
			- A = Attiva dalla mano il primo effetto: scarta il Saggio, scegli 1 tuo mostro sul Terreno da mandare al Cimitero, poi Evoca Specialmente 1 “Drago Bianco Occhi Blu” o 1 “Drago Spirito Occhi Blu” dalla tua mano/Deck/Cimitero. Dopo la scelta del mostro, scegli la posizione (Attacco/Defense scoperto).
			- E = Evoca Normalmente il Saggio.
			- P = Posiziona il Saggio coperto (Set) in zona Mostri.
		- Trigger on‑summon (alla Normal o Special Summon del Saggio): si apre un overlay che mostra i Draghi di Livello 1 nel Deck; scegli 1 da aggiungere alla mano. Il titolo dell’overlay in questo caso è: “scegli il mostro da aggiungere alla mano”.
	- Note importanti
		- Naming resiliente: l’engine accetta sia “Saggio con Occhi di Blu” sia “Saggio con gli Occhi Blu” (nome presente nei JSON). L’effetto on‑summon è registrato sul nome dei dati JSON (“Saggio con gli Occhi Blu”).
		- Scelta del Drago da Special Summon dopo il sacrificio: candidati raccolti da mano, Deck e Cimitero; titolazione overlay “Scegli il mostro da evocare”, poi prompt di posizione.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Events/EventDispatcher.h
			- Aggiunti eventi: `OwnMonsterChoiceRequested`, `DeckAddLevel1DragonChoiceRequested`, `BlueEyesSSChoiceRequested`.
		- GameLogic/Game/Game.h, Game.cpp
			- Abilitata l’attivazione effetto dalla mano per il Saggio: `canActivateMonsterFromHand(...)` e `activateMonsterFromHand(...)` con gating sul nome carta (supporto ai due varianti di nome) e turn owner.
			- Flusso “A” del Saggio: richiesta di scelta di un proprio mostro da mandare al Cimitero (`OwnMonsterChoiceRequested`) → rimozione e tracciamento effetto → richiesta di scelta BEWD/Spirit tra mano/Deck/Cimitero (`BlueEyesSSChoiceRequested`) → `SpecialSummonChoiceRequested` per la posizione.
			- Trigger on‑summon del Saggio: `requestAddLevel1DragonFromDeck(owner)` che emette `DeckAddLevel1DragonChoiceRequested`; `resolvePendingAddLevel1Dragon(...)` aggiunge alla mano e chiude la scelta.
			- Stati pendenti dedicati: `pendingAddLvl1` per l’aggiunta Draghi Lv1, stato per la scelta BEWD/Spirit, stato per “own monster choice” (per il sacrificio).
		- GameLogic/Game/Effects/cards/BluEyes/SageWithEyesOfBlue/SageWithEyesOfBlueEffect.cpp
			- Implementato trigger alla Normal/Special Summon; controllo presenza Saggio sul Terreno con doppia variante nome.
		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Gestione UI e AI per i nuovi eventi:
				- `OwnMonsterChoiceRequested`: mostra feedback “Seleziona un tuo mostro da mandare al Cimitero” e blocca input non pertinenti; il click sul proprio mostro concluderà la scelta (instradato da main/InputController).
				- `DeckAddLevel1DragonChoiceRequested`: apre overlay riusato (Deck) filtrato a Draghi di Livello 1; P2 AI auto‑pick casuale; titolo impostato da main come richiesto.
				- `BlueEyesSSChoiceRequested`: concatena candidati da mano/Deck/Cimitero per BEWD/Spirit, overlay riusato; P2 AI auto‑pick; alla conferma viene emesso `SpecialSummonChoiceRequested` per la posizione.
		- Progetto/Tappa_16/InputController/InputController.cpp
			- Durante il drag sopra la zona Mostri, intercetta A/E/P: A invoca l’attivazione dalla mano del Saggio via Game, E/P seguono i flussi standard di Summon/Set.
		- Progetto/Tappa_16/main.cpp
			- Prompt durante drag: se la carta trascinata è il Saggio, HUD con “A per Attivare, E per Evocare, P per Posizionare”.
			- Overlay Deck riusato per le scelte: titolo personalizzato per Melodia (“…da aggiungere alla mano”), per Richiamo (“Scegli il mostro da evocare”) e per l’aggiunta Draghi Lv1 del Saggio (“scegli il mostro da aggiungere alla mano”).
		- Progetto/Tappa_16/GameWiring/GameWiring.cpp
			- Registrazione effetto on‑summon del Saggio usando il nome JSON “Saggio con gli Occhi Blu”.

- **La Melodia del Drago che si Risveglia**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 carta in mano da scartare e nel Deck almeno un Drago con ATK ≥ 3000 e DEF ≤ 2500.
		- Flusso P1 (umano): seleziona una carta in mano da scartare; si apre un pannello che mostra i Draghi 3000/2500 dal Deck da aggiungere alla mano. È possibile aggiungerne fino a 2 nella stessa risoluzione (il pannello resta aperto per la seconda scelta). ESC termina la selezione anticipatamente.
		- Flusso P2 (AI): scarta casualmente una carta dalla mano e sceglie casualmente fra i bersagli validi nel Deck.
		- UX: titolo specifico “Scegli un Mostro Drago dal Deck da aggiungere alla mano” e hint che indica la doppia scelta possibile.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp:
      - `requestHandDiscard(int ownerIdx)`: apre la scelta di scarto per l'owner, segnando chi è l'owner di scarto ed emettendo HandDiscardChoiceRequested (delegando quindi il lavoro all'App Handler); fallisce se la mano è vuota o già occupata da un'altra scelta.
      - `resolvePendingHandDiscard(size_t handIndex)`: scarta la carta selezionata dalla mano al Cimitero, chiude la scelta di scarto e, se pianificato avvia un qualcosa post scarto come per esempio la scelta dal Deck per Melodia. Altrimenti si limita solo allo scarto della carta 
      - `setMelodiaAddsRemaining(int n)`: imposta quante aggiunte dal Deck sono ancora possibili per la Melodia (fino a 2).
      - `setNextAddFromDeckAfterDiscard(int ownerIdx)`: pianifica che, al termine dello scarto, venga richiesta l'aggiunta dal Deck per lo stesso owner (emette DeckAddChoiceRequested).
      - `hasPendingAddFromDeck() const`: true se c'è una scelta di aggiunta dal Deck in corso. 
      - `resolvePendingAddFromDeck(size_t idx)`: aggiunge alla mano la carta selezionata dalla lista candidati; decrementa il contatore e, se rimangono scelte, riapre la lista; altrimenti chiude.
		- Attributi/stato introdotti per Melodia in `Game`:
			- `struct PendingDiscardHand { int ownerIdx; }` e `std::optional<PendingDiscardHand> pendingDiscard`: traccia la richiesta di scarto in corso.
			- `struct PendingAddDeck { int ownerIdx; }` e `std::optional<PendingAddDeck> pendingAdd`: traccia la richiesta di aggiunta dal Deck in corso.
			- `int melodiaAddsRemaining`: contatore delle aggiunte residue (0 = nessuna in corso).
			- `std::optional<int> nextAddAfterDiscardOwner`: se valorizzato, dopo lo scarto avvia automaticamente la scelta dal Deck per l'owner indicato.

		- GameLogic/Game/Effects/cards/BluEyes/LaMelodiaDelDragoCheSiRisveglia/LaMelodiaDelDragoCheSiRisvegliaEffect.cpp
			- `resolve()`: Chiama prima la requestHandDiscard(ownerIdx), che delega il lavoro a Game ed AppHandler. Una volta che la richiesta è andata a buon fine imposto setMelodiaAddsRemaining(2), per segnare che mancano due carte da aggiungere e setNextAddFromDeckAfterDiscard(ownerIdx), che prepara il nextAddAfterDiscardOwner

		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Gestione degli eventi `HandDiscardChoiceRequested` e `DeckAddChoiceRequested`: molto simile alla gestione dell'evento Send. Chiusura prompt risposta, apertura overlay raccogliendo i candidati e in base all'owner si guarda se fare auto-pick (per AI) oppure scelta effettiva --> riuso dell'overlay DeckSend. 

		- Progetto/Tappa_16/main.cpp
			- Setup dell'Overlay di DeckSend (reliquiario) riusato per l’aggiunta dal Deck: Modificata quindi la lambda `confirmDeckSend`, per distinguere la varie casistiche di pending differenti (Send, Add) modifico il titolo/hint dedicati in base alla casistica; inoltre aggiunto anche supporto per seconda scelta della carta da aggiungere. conferma e chiusura condizionale. La lambda confinrmDeckSend si occupa quindi di vedere se vi sono richieste pendenti, e in tal caso chiamare le risolve. Se la resolve va a buon fine, ma vi è ancora un richiesta significa che è la seconda scelta (la lambda viene poi passata ad InputController e gestito il tutto da lui)

		- Progetto/Tappa_16/Utils/RenderUtils.h
			- `drawDeckSendOverlay(..., titleOverride, hintOverride)` per personalizzare titolo e hint dell’overlay.

- **Richiamo del Posseduto (semplificato)**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 Mostro nel proprio Cimitero e spazio disponibile in zona Mostri.
		- Flusso P1 (umano): si apre un pannello che mostra solo i Mostri nel Cimitero con titolo “Scegli il mostro da evocare”. Dopo la selezione, il Mostro viene Evocato Specialmente in Posizione di Attacco (scoperta).
		- Flusso P2 (AI): seleziona casualmente un Mostro dal Cimitero e lo evoca.
		- Nota: il “link” continuo classico (se la Trappola lascia il Terreno, distruggi quel Mostro) è pianificato come follow‑up e non implementato qui.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp
			- `requestSelectFromGraveyard(int ownerIdx)`: apre la scelta nel Cimitero dell'owner filtrando implicitamente ai Mostri; emette GraveyardChoiceRequested; fallisce se non ci sono Mostri.
			- `resolvePendingSelectFromGraveyard(size_t indexInOwnerGY)`: prende il Mostro all'indice reale del Cimitero dell'owner, lo rimuove dal Cimitero e lo evoca specialmente scoperto in Posizione di Attacco; chiude la scelta.
			- `cancelPendingSelectFromGraveyard()`: annulla e chiude la scelta corrente dal Cimitero.
			- `getPendingGraveyardOwner() const`: restituisce l'owner della scelta Cimitero se presente.
			- `hasPendingGraveyardChoice() const`: true se è attiva una scelta dal Cimitero.
			
			- Attributi/stato introdotti per Richiamo in `Game`:
				- `struct PendingGY { int ownerIdx; }` e `std::optional<PendingGY> pendingGY`: traccia una richiesta di scelta dal Cimitero in corso, salvandone l'owner
		
		- GameLogic/Events/EventDispatcher.h
			- Aggiunto `GameEventType::GraveyardChoiceRequested` per aprire la UI di scelta dal Cimitero.
		
		- GameLogic/Game/Effects/cards/BluEyes/RichiamoDelPosseduto/RichiamoDelPossedutoEffect.cpp
			- resolve(): Apro una richiesta di carta dal cimitero --> `requestSelectFromGraveyard(ownerIdx)` per l’interazione.

		- Progetto/Tappa_16/AppHandlers/AppHandlers.h, AppHandlers.cpp
			- `Context`: aggiunto `setDeckSendIndexMap(std::function<void(const std::vector<size_t>&)>)`.
			- Aggiunto handler per l'evento di tipo `GraveyardChoiceRequested`: P2 (AI) auto-pick tra i Mostri; P1 (umano) apertura overlay con candidati filtrati ai soli Mostri e mappatura indici UI → indici reali nel Cimitero.

		- Progetto/Tappa_16/GameWiring/GameWiring.h, GameWiring.cpp
			- `setupAppHandlers(...)`: aggiornato il setup degli handler per sopportare il nuovo handler aggiunto, e per inizializzarlo nel contex.

		- Progetto/Tappa_16/main.cpp:
			- Overlay riusato anche per il Cimitero; introdotto deckSendIndexMap per mappare la selezione sull’indice reale nel Cimitero.
			- Conferma: se hasPendingGraveyardChoice(), mappa l'indice UI → indice reale tramite deckSendIndexMap e poi chiama resolvePendingSelectFromGraveyard(mapped).
			- Titolo dell’overlay: “Scegli il mostro da evocare”.

- **Rivali Predestinati (semplificato)**
	- Cosa fa
		- Applica una negazione a durata turno secondo le regole semplificate del progetto; integrato nel sistema di attivazioni/chain.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Effects/cards/BluEyes/RivaliPredestinati/RivaliPredestinatiEffect.cpp
			- Effetto registrato come attivazione e applicazione della negazione via helper sul Game.
		- GameLogic/Game/Game.h, Game.cpp
			- Helper/flag per tenere traccia della negazione a durata turno e verifiche negli hook opportuni.

### Altre modifiche di sistema e UX
- Prompt rapido A/E/P su drag del mostro dalla mano alla zona Mostri, con controllo di attivabilità (A) e fallback alle azioni standard (E/P).
- Titolo overlay per “aggiungi Drago di Livello 1” (trigger del Saggio): impostato come “scegli il mostro da aggiungere alla mano”.
- Prompt di risposta/chain (dalla Tappa 15, rifinito): apertura su eventi rilevanti, mostra solo ST attivabili del giocatore locale (P1), e viene chiuso prima dei pannelli modali. La chain risolve LIFO; ESC effettua pass locale e, in demo, auto-pass dell’AI.
- Regola M/T: attivazione dalla zona M/T consentita solo se la carta è settata (faccia in giù). Previene ri‑prompts per Trappole Continue già scoperte.
- Rendering mano: texture fronte garantite e mantenimento della dimensione originale dopo lo swap di texture.
- Overlay unificato (Deck/Cimitero): riuso con title/hint contestuali e mappatura indici quando la lista è filtrata.

### Nuovi attributi/variabili di stato (riepilogo)
- In `Game` (Game.h):
	- Chain/risposta: `bool chainActive`, `int lastResponder` — tracciamento finestra di risposta e ultimo giocatore che ha risposto.
	- Negazione a durata turno: `std::array<bool,2> negateOppMonsterEffUntilEndOfTurn` — supporto a Rivali Predestinati (per owner 0/1).
	- Trigger cimitero: `std::optional<LastSentToGrave> lastSentToGrave` e relativo struct.
	- Evocazioni speciali con scelta: `struct PendingSS { int ownerIdx; Card card; }`, `std::optional<PendingSS> pendingSS`.
	- Scelta invio dal Deck: `struct PendingSendDeck { int ownerIdx; }`, `std::optional<PendingSendDeck> pendingSend`.
	- Scarto mano (Melodia): `struct PendingDiscardHand { int ownerIdx; }`, `std::optional<PendingDiscardHand> pendingDiscard`.
	- Aggiunta dal Deck (Melodia): `struct PendingAddDeck { int ownerIdx; }`, `std::optional<PendingAddDeck> pendingAdd`.
	- Scelta dal Cimitero (Richiamo): `struct PendingGY { int ownerIdx; }`, `std::optional<PendingGY> pendingGY`.
	- Sequenza Melodia: `std::optional<int> nextAddAfterDiscardOwner`, `int melodiaAddsRemaining`.
	- Summon con tributi (slot-aware): `std::optional<size_t> pendingSummonSlotIndex`.
- In `AppHandlers::Context`:
	- `std::function<void(const std::vector<size_t>&)> setDeckSendIndexMap` — consente alla UI di ricevere la mappatura indici UI → indici reali della sorgente (usata per Cimitero filtrato ai Mostri).
- In `main.cpp` (UI state):
	- `std::vector<size_t> deckSendIndexMap` — mappatura degli indici per l’overlay riusato.

### Eventi introdotti
- `OwnMonsterChoiceRequested`: richiesta di selezionare un proprio mostro sul Terreno (usato dal Saggio per il sacrificio).
- `DeckAddLevel1DragonChoiceRequested`: richiesta di selezionare un Drago di Livello 1 dal Deck da aggiungere alla mano (trigger on‑summon del Saggio).
- `BlueEyesSSChoiceRequested`: richiesta di selezionare “Drago Bianco Occhi Blu” o “Drago Spirito Occhi Blu” dalla mano/Deck/Cimitero prima della Special Summon.
- (esistenti/riusati) `SpecialSummonChoiceRequested`, `DeckAddChoiceRequested`, `DeckSendChoiceRequested`, `GraveyardChoiceRequested`.

### Bugfix e robustezza
- Crash durante Normal Summon risolto eliminando duplicazioni di emissione evento/aggiornamento flag; centralizzazione in `tryNormalSummonToSlot`.
- Crash durante drag‑over (prompt A/E/P) risolto catturando gli indici necessari prima di `cancelActiveDrag()`.
- Incoerenze nominali risolte per il Saggio: codice aggiornato ad accettare sia “Saggio con Occhi di Blu” che “Saggio con gli Occhi Blu”; registrazione effetti allineata ai JSON. Verificata presenza risorsa “Drago Spirito Occhi Blu”.

### Fanciulla con gli Occhi di Blu (prima iterazione)
- Trigger implementato: quando la Fanciulla diventa bersaglio di un attacco, si apre la scelta per Evocare Specialmente 1 “Drago Bianco Occhi Blu” o 1 “Drago Spirito Occhi Blu” dalla Mano/Deck/Cimitero del suo controllore, quindi scelta posizione (Attacco/Difesa scoperto). P1 interattivo; P2 auto‑pick.
- Limitazioni note: non è ancora gestito il trigger quando diventa bersaglio di un effetto; l’attacco non viene annullato/rindirizzato in questa iterazione.
- Come testare: metti la Fanciulla sul Terreno di P1, attacca con un mostro P2 scegliendola come bersaglio: vedrai l’overlay di scelta BEWD/Spirit, poi la scelta posizione.

### File toccati (principali)
- `Progetto/Tappa_16/GameWiring/GameWiring.cpp`: registrazione effetto Saggio con nome JSON; setup handler.
- `Progetto/Tappa_16/GameLogic/Game/Game.h|.cpp`: attivazione dalla mano per Saggio; pending e resolve per Lv1 Dragon add; scelta BEWD/Spirit; normal summon centralizzata; eventi emessi; fix crash.
- `Progetto/Tappa_16/GameLogic/Events/EventDispatcher.h`: aggiunta dei nuovi GameEventType.
- `Progetto/Tappa_16/GameLogic/Game/Effects/cards/BluEyes/SageWithEyesOfBlue/SageWithEyesOfBlueEffect.cpp`: trigger on‑summon.
- `Progetto/Tappa_16/AppHandlers/AppHandlers.cpp`: handler UI/AI per nuove scelte; feedback; overlay wiring.
- `Progetto/Tappa_16/InputController/InputController.cpp`: gestione A/E/P in drag‑over su zona Mostri.
- `Progetto/Tappa_16/main.cpp`: prompt in HUD, overlay title/hint dinamici, ordine di risoluzione delle conferme (AddFromDeck → AddLevel1 → SendFromDeck → BlueEyesSS → GraveyardChoice), fix prompt testuali.