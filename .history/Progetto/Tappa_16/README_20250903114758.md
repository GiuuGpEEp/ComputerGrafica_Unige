## Tappa 16 — Implementazione degli effetti mancanti

Di seguito gli effetti implementati/rifiniti e, per ciascuno, la descrizione funzionale e le modifiche ai file necessarie per ottenerne il comportamento.

### Aggiornamenti recenti (set 2025)

Questo changelog documenta le ultime modifiche rispetto alla precedente versione del README. Ogni voce include la motivazione tecnica/UX.

- P2 (AI) auto‑risoluzione sacrificio del Saggio, senza prompt
	- Cosa cambia: quando l’evento `OwnMonsterChoiceRequested` riguarda l’owner 1 (P2), la selezione del proprio mostro da mandare al Cimitero avviene automaticamente in modo casuale, senza aprire prompt UI.
	- Dove: `Progetto/Tappa_16/AppHandlers/AppHandlers.cpp`, handler di `OwnMonsterChoiceRequested` (ramo owner==1: pick random e resolve immediato; owner==0 resta il prompt per P1).
	- Perché: coerenza con il design “P2 è AI e non deve interrompere il flusso con pannelli modali”. Riduce attriti e rende l’azione del Saggio lato avversario completamente automatica.

- Titolo overlay per la scelta BEWD/Spirito aggiornato
	- Cosa cambia: quando è attiva `hasPendingBlueEyesSSChoice()`, l’overlay usa il titolo “Seleziona mostro da evocare specialmente”.
	- Dove: `Progetto/Tappa_16/main.cpp`, sezione render dell’overlay riusato (DeckSend) con `titleOverride`.
	- Perché: chiarezza testuale. Il titolo precedente poteva essere ambiguo/ereditato (“…mandare al cimitero”). Ora comunica esplicitamente la Special Summon in arrivo.

- P2 auto‑scelta della posizione nella Special Summon
	- Cosa cambia: all’evento `SpecialSummonChoiceRequested`, per P2 la posizione (Attacco/Difesa) viene scelta casualmente senza prompt. Per P1 resta l’overlay.
	- Dove: `Progetto/Tappa_16/AppHandlers/AppHandlers.cpp`, handler di `SpecialSummonChoiceRequested` con ramo AI (auto‑pick) e ramo umano (apertura overlay posizione).
	- Perché: uniformare l’esperienza no‑prompt dell’AI anche nella seconda parte del flusso (post scelta BEWD/Spirito).

- Pietra Bianca degli Antichi: trigger indipendente per entrambi i giocatori nella stessa End Phase
	- Cosa cambia: se entrambe le copie vengono mandate al Cimitero nello stesso turno (per esempio per distruzione reciproca), all’End Phase si risolvono entrambe le evocazioni speciali (una per ciascun giocatore), ognuna dal proprio Deck.
	- Dove: `GameLogic/Game/Effects/cards/BluEyes/WhiteStoneAncients/WhiteStoneAncientsEffect.{h,cpp}`. Lo stato è ora per‑giocatore (`pendingFor[2]`) e in End Phase si processano entrambi i pending (ordine: AI/P2 → P1), chiamando `requestSpecialSummonWithChoice` per ciascuno.
	- Perché: la versione precedente tracciava un singolo pending globale e poteva perdere un’attivazione quando due Pietre venivano mandate al Cimitero nello stesso turno.

- Bugfix: impossibile Evocare normalmente dopo il sacrificio del Saggio nonostante slot libero
	- Sintomo: con 2 mostri sul Terreno e 1 slot libero, dopo aver usato il sacrificio del Saggio, la Normal Summon poteva risultare bloccata.
	- Root cause: la mappatura degli slot (`monsterSlotIndex`) non veniva aggiornata quando il mostro veniva rimosso dal campo all’interno di `resolvePendingSelectOwnMonster` (sacrificio). La funzione `firstFreeMonsterSlot(...)` si basa su quella mappatura e “vedeva” lo slot come occupato.
	- Fix: in `Game::resolvePendingSelectOwnMonster` (file `Game.cpp`), oltre a rimuovere i flag associati al mostro sacrificato, ora viene anche cancellata l’entry corrispondente in `monsterSlotIndex[cur]`. Ciò libera lo slot nella mappatura, ripristinando la corretta rilevazione dello spazio libero per le Normal Summon.
	- Perché: garantire coerenza tra stato logico della zona Mostri e mappatura grafico‑slot, su cui si appoggiano i controlli di disponibilità (`isMonsterSlotOccupied`/`firstFreeMonsterSlot`).

### Effetti implementati/rifiniti 

- **Saggio con (gli) Occhi di Blu**
	- Cosa fa (tutti i flussi sono a scelta P1; P2 è auto‑risolto dall'AI)
		- Prompt A/E/P quando trascini il Saggio dalla mano sopra la zona Mostri:
			- A = Attiva dalla mano il primo effetto: scarta il Saggio, scegli 1 tuo mostro sul Terreno da mandare al Cimitero, poi Evoca Specialmente 1 “Drago Bianco Occhi Blu” o 1 “Drago Spirito del Bianco” dalla tua mano/Deck/Cimitero. Dopo la scelta del mostro, scegli la posizione (Attacco/Defense scoperto).
			- E = Evoca Normalmente il Saggio.
			- P = Posiziona il Saggio coperto (Set) in zona Mostri.
		- Trigger on‑summon (alla Normal o Special Summon del Saggio): si apre un overlay che mostra i Draghi di Livello 1 nel Deck; scegli 1 da aggiungere alla mano. Il titolo dell’overlay in questo caso è: “scegli il mostro da aggiungere alla mano”.
	- Note importanti
		- Naming resiliente: l’engine accetta sia “Saggio con Occhi di Blu” sia “Saggio con gli Occhi Blu” (nome presente nei JSON). L’effetto on‑summon è registrato sul nome dei dati JSON (“Saggio con gli Occhi Blu”).
		- Scelta del Drago da Special Summon dopo il sacrificio: candidati raccolti da mano, Deck e Cimitero; titolazione overlay “Scegli il mostro da evocare”, poi prompt di posizione.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Events/EventDispatcher.h
			- Aggiunti eventi: `OwnMonsterChoiceRequested`, `DeckAddLevel1DragonChoiceRequested`, `BlueEyesSSChoiceRequested`.
		- GameLogic/Game/Game.h, Game.cpp
			- Abilitata l’attivazione effetto dalla mano per il Saggio: `canActivateMonsterFromHand(...)` e `activateMonsterFromHand(...)` con gating sul nome carta (supporto ai due varianti di nome) e turn owner.
			- Flusso “A” del Saggio: richiesta di scelta di un proprio mostro da mandare al Cimitero (`OwnMonsterChoiceRequested`) → rimozione e tracciamento effetto → richiesta di scelta BEWD/Spirit tra mano/Deck/Cimitero (`BlueEyesSSChoiceRequested`) → `SpecialSummonChoiceRequested` per la posizione.
			- Trigger on‑summon del Saggio: `requestAddLevel1DragonFromDeck(owner)` che emette `DeckAddLevel1DragonChoiceRequested`; `resolvePendingAddLevel1Dragon(...)` aggiunge alla mano e chiude la scelta.
			- Stati pendenti dedicati: `pendingAddLvl1` per l’aggiunta Draghi Lv1, stato per la scelta BEWD/Spirit, stato per “own monster choice” (per il sacrificio).
		- GameLogic/Game/Effects/cards/BluEyes/SageWithEyesOfBlue/SageWithEyesOfBlueEffect.cpp
			- Implementato trigger alla Normal/Special Summon; controllo presenza Saggio sul Terreno con doppia variante nome.
		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Gestione UI e AI per i nuovi eventi:
				- `OwnMonsterChoiceRequested`: mostra feedback “Seleziona un tuo mostro da mandare al Cimitero” e blocca input non pertinenti; il click sul proprio mostro concluderà la scelta (instradato da main/InputController).
				- `DeckAddLevel1DragonChoiceRequested`: apre overlay riusato (Deck) filtrato a Draghi di Livello 1; P2 AI auto‑pick casuale; titolo impostato da main come richiesto.
				- `BlueEyesSSChoiceRequested`: concatena candidati da mano/Deck/Cimitero per BEWD/Spirit, overlay riusato; P2 AI auto‑pick; alla conferma viene emesso `SpecialSummonChoiceRequested` per la posizione.
		- Progetto/Tappa_16/InputController/InputController.cpp
			- Durante il drag sopra la zona Mostri, intercetta A/E/P: A invoca l’attivazione dalla mano del Saggio via Game, E/P seguono i flussi standard di Summon/Set.
		- Progetto/Tappa_16/main.cpp
			- Prompt durante drag: se la carta trascinata è il Saggio, HUD con “A per Attivare, E per Evocare, P per Posizionare”.
			- Overlay Deck riusato per le scelte: titolo personalizzato per Melodia (“…da aggiungere alla mano”), per Richiamo (“Scegli il mostro da evocare”) e per l’aggiunta Draghi Lv1 del Saggio (“scegli il mostro da aggiungere alla mano”).
		- Progetto/Tappa_16/GameWiring/GameWiring.cpp
			- Registrazione effetto on‑summon del Saggio usando il nome JSON “Saggio con gli Occhi Blu”.

- **Fanciulla con gli Occhi di Blu**
	- Cosa fa
		- Quando questa carta viene scelta come bersaglio di un attacco, il suo controllore può Evocare Specialmente 1 “Drago Bianco Occhi Blu” o 1 “Drago Spirito del Bianco” dalla propria mano, Deck o Cimitero. Dopo la scelta, seleziona la posizione (Attacco/Difesa, scoperto).
	- Flusso e regole
		- Trigger: all’evento `AttackDeclared` con bersaglio presente; si determina il difensore (owner della Fanciulla bersagliata) e si avvia la richiesta di scelta BEWD/Spirito per quel giocatore.
		- Negazioni: se gli effetti dei mostri del difensore risultano annullati in questo turno (es. da “Rivali Predestinati”), l’effetto non si applica.
		- Re‑entrancy guard: se è già attiva una richiesta pendente di scelta Blue‑Eyes (`hasPendingBlueEyesSSChoice()`), non si apre una nuova scelta per evitare sovrapposizioni.
		- UX: per P1 si apre l’overlay con titolo “Seleziona mostro da evocare specialmente”; per P2 la scelta del mostro è automatica (random) e anche la scelta della posizione è automatica (random) senza prompt.
	- Cosa è stato aggiunto/modificato nei file
		- GameWiring/GameWiring.cpp
			- Registrazione dell’effetto: `game.registerEffectForCardName("Fanciulla con gli Occhi di Blu", std::make_unique<MaidenWithEyesOfBlueEffect>());`
		- GameLogic/Game/Effects/cards/BluEyes/MaidenWithEyesOfBlue/
			- `MaidenWithEyesOfBlueEffect.h/.cpp`: ascolta `AttackDeclared`, verifica che il bersaglio sia la Fanciulla (match robusto su nome con e senza “gli”), controlla le negazioni, quindi invoca `requestBlueEyesOrSpiritChoice(defender)`.
		- GameLogic/Game/Game.cpp
			- Pulizia: la gestione inline storica della Fanciulla in `declareAttack` è stata rimossa/commentata e spostata nel sistema di effetti (si vedono i commenti “Rimozione: il trigger della Fanciulla è ora implementato come effetto dedicato…”).
		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Handler `BlueEyesSSChoiceRequested`: costruzione candidati da mano/Deck/Cimitero; per P2 auto‑pick casuale, per P1 apertura overlay; alla conferma viene emesso `SpecialSummonChoiceRequested`.
			- Handler `SpecialSummonChoiceRequested`: per P2 auto‑scelta (Attacco/Difesa) senza prompt; per P1 overlay a due tasti.
		- Progetto/Tappa_16/main.cpp
			- Overlay riusato per la scelta Blue‑Eyes/Spirito con titolo “Seleziona mostro da evocare specialmente”.
	- Perché
		- Separazione delle responsabilità: spostare il trigger della Fanciulla dal combattimento “inline” al sistema effetti favorisce la manutenibilità e riduce regressioni.
		- Coerenza UX/AI: riuso dello stesso flusso di selezione di Saggio per mano/Deck/Cimitero; AI sempre no‑prompt, P1 con prompt chiari.

- **Pietra Bianca degli Antichi (rework)**
	- Cosa fa
		- Se questa carta viene mandata al Cimitero in questo turno, durante l’End Phase il suo proprietario può Evocare Specialmente 1 “Drago Bianco Occhi Blu” dal proprio Deck. Se entrambe le Pietre (dei due giocatori) sono state mandate al Cimitero nello stesso turno, entrambe si risolvono nella stessa End Phase, ognuna per il rispettivo proprietario.
	- Flusso e regole
		- Tracciamento: all’evento `CardSentToGrave` si marca `pendingFor[owner] = true` per quel turno; all’evento `TurnStart` i pending vengono resettati.
		- Risoluzione: all’ingresso in End Phase, per ciascun owner con pending si rimuove dal suo Deck il primo “Drago Bianco Occhi Blu”, si esegue `mirrorExternalDeckRemoveByName` per tenere in sync la UI, quindi si chiama `requestSpecialSummonWithChoice(owner, card)`.
		- Ordine: per coerenza UX, si processa prima l’AI/P2 e poi P1. Per P2 la posizione (Attacco/Difesa) è scelta automaticamente; per P1 si apre l’overlay di scelta posizione.
		- Vincoli: se il Deck non contiene “Drago Bianco Occhi Blu” o la Zona Mostri è piena, quell’istanza non evoca; l’altra (se presente) continua a risolversi normalmente.
	- Cosa è stato aggiunto/modificato nei file
		- `GameLogic/Game/Effects/cards/BluEyes/WhiteStoneAncients/WhiteStoneAncientsEffect.h`: sostituito lo stato singolo con `std::array<bool,2> pendingFor`.
		- `.../WhiteStoneAncientsEffect.cpp`: aggiornate le routine per CardSentToGrave/TurnStart/PhaseChange (End) per gestire entrambi i pending nello stesso turno.

- **La Melodia del Drago che si Risveglia**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 carta in mano da scartare e nel Deck almeno un Drago con ATK ≥ 3000 e DEF ≤ 2500.
		- Flusso P1 (umano): seleziona una carta in mano da scartare; si apre un pannello che mostra i Draghi 3000/2500 dal Deck da aggiungere alla mano. È possibile aggiungerne fino a 2 nella stessa risoluzione (il pannello resta aperto per la seconda scelta). ESC termina la selezione anticipatamente.
		- Flusso P2 (AI): scarta casualmente una carta dalla mano e sceglie casualmente fra i bersagli validi nel Deck.
		- UX: titolo specifico “Scegli un Mostro Drago dal Deck da aggiungere alla mano” e hint che indica la doppia scelta possibile.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp:
      - `requestHandDiscard(int ownerIdx)`: apre la scelta di scarto per l'owner, segnando chi è l'owner di scarto ed emettendo HandDiscardChoiceRequested (delegando quindi il lavoro all'App Handler); fallisce se la mano è vuota o già occupata da un'altra scelta.
      - `resolvePendingHandDiscard(size_t handIndex)`: scarta la carta selezionata dalla mano al Cimitero, chiude la scelta di scarto e, se pianificato avvia un qualcosa post scarto come per esempio la scelta dal Deck per Melodia. Altrimenti si limita solo allo scarto della carta 
      - `setMelodiaAddsRemaining(int n)`: imposta quante aggiunte dal Deck sono ancora possibili per la Melodia (fino a 2).
      - `setNextAddFromDeckAfterDiscard(int ownerIdx)`: pianifica che, al termine dello scarto, venga richiesta l'aggiunta dal Deck per lo stesso owner (emette DeckAddChoiceRequested).
      - `hasPendingAddFromDeck() const`: true se c'è una scelta di aggiunta dal Deck in corso. 
      - `resolvePendingAddFromDeck(size_t idx)`: aggiunge alla mano la carta selezionata dalla lista candidati; decrementa il contatore e, se rimangono scelte, riapre la lista; altrimenti chiude.
		- Attributi/stato introdotti per Melodia in `Game`:
			- `struct PendingDiscardHand { int ownerIdx; }` e `std::optional<PendingDiscardHand> pendingDiscard`: traccia la richiesta di scarto in corso.
			- `struct PendingAddDeck { int ownerIdx; }` e `std::optional<PendingAddDeck> pendingAdd`: traccia la richiesta di aggiunta dal Deck in corso.
			- `int melodiaAddsRemaining`: contatore delle aggiunte residue (0 = nessuna in corso).
			- `std::optional<int> nextAddAfterDiscardOwner`: se valorizzato, dopo lo scarto avvia automaticamente la scelta dal Deck per l'owner indicato.

		- GameLogic/Game/Effects/cards/BluEyes/LaMelodiaDelDragoCheSiRisveglia/LaMelodiaDelDragoCheSiRisvegliaEffect.cpp
			- `resolve()`: Chiama prima la requestHandDiscard(ownerIdx), che delega il lavoro a Game ed AppHandler. Una volta che la richiesta è andata a buon fine imposto setMelodiaAddsRemaining(2), per segnare che mancano due carte da aggiungere e setNextAddFromDeckAfterDiscard(ownerIdx), che prepara il nextAddAfterDiscardOwner

		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Gestione degli eventi `HandDiscardChoiceRequested` e `DeckAddChoiceRequested`: molto simile alla gestione dell'evento Send. Chiusura prompt risposta, apertura overlay raccogliendo i candidati e in base all'owner si guarda se fare auto-pick (per AI) oppure scelta effettiva --> riuso dell'overlay DeckSend. 

		- Progetto/Tappa_16/main.cpp
			- Setup dell'Overlay di DeckSend (reliquiario) riusato per l’aggiunta dal Deck: Modificata quindi la lambda `confirmDeckSend`, per distinguere la varie casistiche di pending differenti (Send, Add) modifico il titolo/hint dedicati in base alla casistica; inoltre aggiunto anche supporto per seconda scelta della carta da aggiungere. conferma e chiusura condizionale. La lambda confinrmDeckSend si occupa quindi di vedere se vi sono richieste pendenti, e in tal caso chiamare le risolve. Se la resolve va a buon fine, ma vi è ancora un richiesta significa che è la seconda scelta (la lambda viene poi passata ad InputController e gestito il tutto da lui)

		- Progetto/Tappa_16/Utils/RenderUtils.h
			- `drawDeckSendOverlay(..., titleOverride, hintOverride)` per personalizzare titolo e hint dell’overlay.

- **Richiamo del Posseduto (semplificato)**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 Mostro nel proprio Cimitero e spazio disponibile in zona Mostri.
		- Flusso P1 (umano): si apre un pannello che mostra solo i Mostri nel Cimitero con titolo “Scegli il mostro da evocare”. Dopo la selezione, il Mostro viene Evocato Specialmente in Posizione di Attacco (scoperta).
		- Flusso P2 (AI): seleziona casualmente un Mostro dal Cimitero e lo evoca.
		- Nota: il “link” continuo classico (se la Trappola lascia il Terreno, distruggi quel Mostro) è pianificato come follow‑up e non implementato qui.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp
			- `requestSelectFromGraveyard(int ownerIdx)`: apre la scelta nel Cimitero dell'owner filtrando implicitamente ai Mostri; emette GraveyardChoiceRequested; fallisce se non ci sono Mostri.
			- `resolvePendingSelectFromGraveyard(size_t indexInOwnerGY)`: prende il Mostro all'indice reale del Cimitero dell'owner, lo rimuove dal Cimitero e lo evoca specialmente scoperto in Posizione di Attacco; chiude la scelta.
			- `cancelPendingSelectFromGraveyard()`: annulla e chiude la scelta corrente dal Cimitero.
			- `getPendingGraveyardOwner() const`: restituisce l'owner della scelta Cimitero se presente.
			- `hasPendingGraveyardChoice() const`: true se è attiva una scelta dal Cimitero.
			
			- Attributi/stato introdotti per Richiamo in `Game`:
				- `struct PendingGY { int ownerIdx; }` e `std::optional<PendingGY> pendingGY`: traccia una richiesta di scelta dal Cimitero in corso, salvandone l'owner
		
		- GameLogic/Events/EventDispatcher.h
			- Aggiunto `GameEventType::GraveyardChoiceRequested` per aprire la UI di scelta dal Cimitero.
		
		- GameLogic/Game/Effects/cards/BluEyes/RichiamoDelPosseduto/RichiamoDelPossedutoEffect.cpp
			- resolve(): Apro una richiesta di carta dal cimitero --> `requestSelectFromGraveyard(ownerIdx)` per l’interazione.

		- Progetto/Tappa_16/AppHandlers/AppHandlers.h, AppHandlers.cpp
			- `Context`: aggiunto `setDeckSendIndexMap(std::function<void(const std::vector<size_t>&)>)`.
			- Aggiunto handler per l'evento di tipo `GraveyardChoiceRequested`: P2 (AI) auto-pick tra i Mostri; P1 (umano) apertura overlay con candidati filtrati ai soli Mostri e mappatura indici UI → indici reali nel Cimitero.

		- Progetto/Tappa_16/GameWiring/GameWiring.h, GameWiring.cpp
			- `setupAppHandlers(...)`: aggiornato il setup degli handler per sopportare il nuovo handler aggiunto, e per inizializzarlo nel contex.

		- Progetto/Tappa_16/main.cpp:
			- Overlay riusato anche per il Cimitero; introdotto deckSendIndexMap per mappare la selezione sull’indice reale nel Cimitero.
			- Conferma: se hasPendingGraveyardChoice(), mappa l'indice UI → indice reale tramite deckSendIndexMap e poi chiama resolvePendingSelectFromGraveyard(mapped).
			- Titolo dell’overlay: “Scegli il mostro da evocare”.

- **Rivali Predestinati (semplificato)**
	- Cosa fa
		- Applica una negazione a durata turno secondo le regole semplificate del progetto; integrato nel sistema di attivazioni/chain.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Effects/cards/BluEyes/RivaliPredestinati/RivaliPredestinatiEffect.cpp
			- Effetto registrato come attivazione e applicazione della negazione via helper sul Game.
		- GameLogic/Game/Game.h, Game.cpp
			- Helper/flag per tenere traccia della negazione a durata turno e verifiche negli hook opportuni.

### Altre modifiche di sistema e UX
- Prompt rapido A/E/P su drag del mostro dalla mano alla zona Mostri, con controllo di attivabilità (A) e fallback alle azioni standard (E/P).
- Titolo overlay per “aggiungi Drago di Livello 1” (trigger del Saggio): impostato come “scegli il mostro da aggiungere alla mano”.
- Prompt di risposta/chain (dalla Tappa 15, rifinito): apertura su eventi rilevanti, mostra solo ST attivabili del giocatore locale (P1), e viene chiuso prima dei pannelli modali. La chain risolve LIFO; ESC effettua pass locale e, in demo, auto-pass dell’AI.
- Regola M/T: attivazione dalla zona M/T consentita solo se la carta è settata (faccia in giù). Previene ri‑prompts per Trappole Continue già scoperte.
- Rendering mano: texture fronte garantite e mantenimento della dimensione originale dopo lo swap di texture.
- Overlay unificato (Deck/Cimitero): riuso con title/hint contestuali e mappatura indici quando la lista è filtrata.

### Nuovi attributi/variabili di stato (riepilogo)
- In `Game` (Game.h):
	- Chain/risposta: `bool chainActive`, `int lastResponder` — tracciamento finestra di risposta e ultimo giocatore che ha risposto.
	- Negazione a durata turno: `std::array<bool,2> negateOppMonsterEffUntilEndOfTurn` — supporto a Rivali Predestinati (per owner 0/1).
	- Trigger cimitero: `std::optional<LastSentToGrave> lastSentToGrave` e relativo struct.
	- Evocazioni speciali con scelta: `struct PendingSS { int ownerIdx; Card card; }`, `std::optional<PendingSS> pendingSS`.
	- Scelta invio dal Deck: `struct PendingSendDeck { int ownerIdx; }`, `std::optional<PendingSendDeck> pendingSend`.
	- Scarto mano (Melodia): `struct PendingDiscardHand { int ownerIdx; }`, `std::optional<PendingDiscardHand> pendingDiscard`.
	- Aggiunta dal Deck (Melodia): `struct PendingAddDeck { int ownerIdx; }`, `std::optional<PendingAddDeck> pendingAdd`.
	- Scelta dal Cimitero (Richiamo): `struct PendingGY { int ownerIdx; }`, `std::optional<PendingGY> pendingGY`.
	- Sequenza Melodia: `std::optional<int> nextAddAfterDiscardOwner`, `int melodiaAddsRemaining`.
	- Summon con tributi (slot-aware): `std::optional<size_t> pendingSummonSlotIndex`.
- In `AppHandlers::Context`:
	- `std::function<void(const std::vector<size_t>&)> setDeckSendIndexMap` — consente alla UI di ricevere la mappatura indici UI → indici reali della sorgente (usata per Cimitero filtrato ai Mostri).
- In `main.cpp` (UI state):
	- `std::vector<size_t> deckSendIndexMap` — mappatura degli indici per l’overlay riusato.

### Eventi introdotti
- `OwnMonsterChoiceRequested`: richiesta di selezionare un proprio mostro sul Terreno (usato dal Saggio per il sacrificio).
- `DeckAddLevel1DragonChoiceRequested`: richiesta di selezionare un Drago di Livello 1 dal Deck da aggiungere alla mano (trigger on‑summon del Saggio).
- `BlueEyesSSChoiceRequested`: richiesta di selezionare “Drago Bianco Occhi Blu” o “Drago Spirito del Bianco” dalla mano/Deck/Cimitero prima della Special Summon.
- (esistenti/riusati) `SpecialSummonChoiceRequested`, `DeckAddChoiceRequested`, `DeckSendChoiceRequested`, `GraveyardChoiceRequested`.

