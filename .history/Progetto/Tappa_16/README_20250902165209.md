## Tappa 16 — Implementazione degli effetti mancanti

Di seguito gli effetti implementati/rifiniti e, per ciascuno, la descrizione funzionale e le modifiche ai file necessarie per ottenerne il comportamento.

### Effetti implementati/rifiniti 

- **La Melodia del Drago che si Risveglia**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 carta in mano da scartare e nel Deck almeno un Drago con ATK ≥ 3000 e DEF ≤ 2500.
		- Flusso P1 (umano): seleziona una carta in mano da scartare; si apre un pannello che mostra i Draghi 3000/2500 dal Deck da aggiungere alla mano. È possibile aggiungerne fino a 2 nella stessa risoluzione (il pannello resta aperto per la seconda scelta). ESC termina la selezione anticipatamente.
		- Flusso P2 (AI): scarta casualmente una carta dalla mano e sceglie casualmente fra i bersagli validi nel Deck.
		- UX: titolo specifico “Scegli un Mostro Drago dal Deck da aggiungere alla mano” e hint che indica la doppia scelta possibile.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp:
      - `requestHandDiscard(int ownerIdx)`: apre la scelta di scarto per l'owner, segnando chi è l'owner di scarto ed emettendo HandDiscardChoiceRequested (delegando quindi il lavoro all'App Handler); fallisce se la mano è vuota o già occupata da un'altra scelta.
      - `resolvePendingHandDiscard(size_t handIndex)`: scarta la carta selezionata dalla mano al Cimitero, chiude la scelta di scarto e, se pianificato avvia un qualcosa post scarto come per esempio la scelta dal Deck per Melodia. Altrimenti si limita solo allo scarto della carta 
      - `setMelodiaAddsRemaining(int n)`: imposta quante aggiunte dal Deck sono ancora possibili per la Melodia (fino a 2).
      - `setNextAddFromDeckAfterDiscard(int ownerIdx)`: pianifica che, al termine dello scarto, venga richiesta l'aggiunta dal Deck per lo stesso owner (emette DeckAddChoiceRequested).
      - `hasPendingAddFromDeck() const`: true se c'è una scelta di aggiunta dal Deck in corso. 
      - `resolvePendingAddFromDeck(size_t idx)`: aggiunge alla mano la carta selezionata dalla lista candidati; decrementa il contatore e, se rimangono scelte, riapre la lista; altrimenti chiude.
		- Attributi/stato introdotti per Melodia in `Game`:
			- `struct PendingDiscardHand { int ownerIdx; }` e `std::optional<PendingDiscardHand> pendingDiscard`: traccia la richiesta di scarto in corso.
			- `struct PendingAddDeck { int ownerIdx; }` e `std::optional<PendingAddDeck> pendingAdd`: traccia la richiesta di aggiunta dal Deck in corso.
			- `int melodiaAddsRemaining`: contatore delle aggiunte residue (0 = nessuna in corso).
			- `std::optional<int> nextAddAfterDiscardOwner`: se valorizzato, dopo lo scarto avvia automaticamente la scelta dal Deck per l'owner indicato.

		- GameLogic/Game/Effects/cards/BluEyes/LaMelodiaDelDragoCheSiRisveglia/LaMelodiaDelDragoCheSiRisvegliaEffect.cpp
			- `resolve()`: Chiama prima la requestHandDiscard(ownerIdx), che delega il lavoro a Game ed AppHandler. Una volta che l'operazione di scarto è andata a buon fine imposto setMelodiaAddsRemaining(2), per segnare che mancano due carte da aggiungere e setNextAddFromDeckAfterDiscard(ownerIdx).

		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Gestione HandDiscardChoiceRequested e DeckAddChoiceRequested: chiusura prompt risposta, apertura overlay con candidati, auto-pick AI, riuso overlay DeckSend.

		- Progetto/Tappa_16/main.cpp
			- Overlay riusato per l’aggiunta dal Deck: titolo/hint dedicati, persistenza per seconda scelta, conferma e chiusura condizionale.

		- Progetto/Tappa_16/Utils/RenderUtils.h
			- drawDeckSendOverlay(..., titleOverride, hintOverride) per personalizzare titolo e hint dell’overlay.

- **Richiamo del Posseduto (semplificato)**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 Mostro nel proprio Cimitero e spazio disponibile in zona Mostri.
		- Flusso P1 (umano): si apre un pannello che mostra solo i Mostri nel Cimitero con titolo “Scegli il mostro da evocare”. Dopo la selezione, il Mostro viene Evocato Specialmente in Posizione di Attacco (scoperta).
		- Flusso P2 (AI): seleziona casualmente un Mostro dal Cimitero e lo evoca.
		- Nota: il “link” continuo classico (se la Trappola lascia il Terreno, distruggi quel Mostro) è pianificato come follow‑up e non implementato qui.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp
				- Flusso pendente per la scelta dal Cimitero:
					- requestSelectFromGraveyard(int ownerIdx): apre la scelta nel Cimitero dell'owner filtrando implicitamente ai Mostri; emette GraveyardChoiceRequested; fallisce se non ci sono Mostri.
					- resolvePendingSelectFromGraveyard(size_t indexInOwnerGY): prende il Mostro all'indice reale del Cimitero dell'owner, lo rimuove dal Cimitero e lo evoca specialmente scoperto in Posizione di Attacco; chiude la scelta.
					- cancelPendingSelectFromGraveyard(): annulla e chiude la scelta corrente dal Cimitero.
					- getPendingGraveyardOwner() const: restituisce l'owner della scelta Cimitero se presente.
					- hasPendingGraveyardChoice() const: true se è attiva una scelta dal Cimitero.
			- Attributi/stato introdotti per Richiamo in `Game`:
				- `struct PendingGY { int ownerIdx; }` e `std::optional<PendingGY> pendingGY`: traccia una richiesta di scelta dal Cimitero in corso.
		- GameLogic/Events/EventDispatcher.h
			- Aggiunto GameEventType::GraveyardChoiceRequested per aprire la UI di scelta dal Cimitero.
		- GameLogic/Game/Effects/cards/BluEyes/RichiamoDelPosseduto/RichiamoDelPossedutoEffect.cpp
			- resolve(): sostituito l’auto-pick con requestSelectFromGraveyard(ownerIdx) per l’interazione.
		- Progetto/Tappa_16/AppHandlers/AppHandlers.h, AppHandlers.cpp
			- Context: aggiunto setDeckSendIndexMap(std::function<void(const std::vector<size_t>&)>).
			- Handler GraveyardChoiceRequested: P2 (AI) auto-pick tra i Mostri; P1 (umano) apertura overlay con candidati filtrati ai soli Mostri e mappatura indici UI → indici reali nel Cimitero.
		- Progetto/Tappa_16/GameWiring/GameWiring.h, GameWiring.cpp
			- setupAppHandlers(...): estesa la firma per ricevere e cablare setDeckSendIndexMap nel Context.
		- Progetto/Tappa_16/main.cpp
		- Overlay riusato anche per il Cimitero; introdotto deckSendIndexMap per mappare la selezione sull’indice reale nel Cimitero.
		- Conferma: se hasPendingGraveyardChoice(), mappa l'indice UI → indice reale tramite deckSendIndexMap e poi chiama resolvePendingSelectFromGraveyard(mapped).
			- Titolo dell’overlay: “Scegli il mostro da evocare”.

- **Rivali Predestinati (semplificato)**
	- Cosa fa
		- Applica una negazione a durata turno secondo le regole semplificate del progetto; integrato nel sistema di attivazioni/chain.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Effects/cards/BluEyes/RivaliPredestinati/RivaliPredestinatiEffect.cpp
			- Effetto registrato come attivazione e applicazione della negazione via helper sul Game.
		- GameLogic/Game/Game.h, Game.cpp
			- Helper/flag per tenere traccia della negazione a durata turno e verifiche negli hook opportuni.

### Altre modifiche di sistema e UX
- Prompt di risposta/chain (dalla Tappa 15, rifinito): apertura su eventi rilevanti, mostra solo ST attivabili del giocatore locale (P1), e viene chiuso prima dei pannelli modali. La chain risolve LIFO; ESC effettua pass locale e, in demo, auto-pass dell’AI.
- Regola M/T: attivazione dalla zona M/T consentita solo se la carta è settata (faccia in giù). Previene ri‑prompts per Trappole Continue già scoperte.
- Rendering mano: texture fronte garantite e mantenimento della dimensione originale dopo lo swap di texture.
- Overlay unificato (Deck/Cimitero): riuso con title/hint contestuali e mappatura indici quando la lista è filtrata.

### Nuovi attributi/variabili di stato (riepilogo)
- In `Game` (Game.h):
	- Chain/risposta: `bool chainActive`, `int lastResponder` — tracciamento finestra di risposta e ultimo giocatore che ha risposto.
	- Negazione a durata turno: `std::array<bool,2> negateOppMonsterEffUntilEndOfTurn` — supporto a Rivali Predestinati (per owner 0/1).
	- Trigger cimitero: `std::optional<LastSentToGrave> lastSentToGrave` e relativo struct.
	- Evocazioni speciali con scelta: `struct PendingSS { int ownerIdx; Card card; }`, `std::optional<PendingSS> pendingSS`.
	- Scelta invio dal Deck: `struct PendingSendDeck { int ownerIdx; }`, `std::optional<PendingSendDeck> pendingSend`.
	- Scarto mano (Melodia): `struct PendingDiscardHand { int ownerIdx; }`, `std::optional<PendingDiscardHand> pendingDiscard`.
	- Aggiunta dal Deck (Melodia): `struct PendingAddDeck { int ownerIdx; }`, `std::optional<PendingAddDeck> pendingAdd`.
	- Scelta dal Cimitero (Richiamo): `struct PendingGY { int ownerIdx; }`, `std::optional<PendingGY> pendingGY`.
	- Sequenza Melodia: `std::optional<int> nextAddAfterDiscardOwner`, `int melodiaAddsRemaining`.
	- Summon con tributi (slot-aware): `std::optional<size_t> pendingSummonSlotIndex`.
- In `AppHandlers::Context`:
	- `std::function<void(const std::vector<size_t>&)> setDeckSendIndexMap` — consente alla UI di ricevere la mappatura indici UI → indici reali della sorgente (usata per Cimitero filtrato ai Mostri).
- In `main.cpp` (UI state):
	- `std::vector<size_t> deckSendIndexMap` — mappatura degli indici per l’overlay riusato.

### Controlli rapidi
- Overlay di scelta (Deck/Cimitero): Invio = Conferma, ESC = Annulla/Termina, Frecce o Click = Cambia selezione.
- Scarto dalla mano (Melodia): clic sulla carta in mano richiesta.
- Prompt di risposta (chain): selezione carta attivabile e conferma; ESC passa la priorità.

### Comportamento dell’AI (P2)
- Scelte casuali per: scarto carta mano (Melodia), aggiunta dal Deck (Melodia), invio/ricerca dal Deck dove previsto, selezione dal Cimitero (Richiamo).

### Limitazioni e prossimi passi
- Richiamo del Posseduto: non implementato (in questa tappa) il legame continuo con il Mostro evocato.
- Alcuni testi/hint del pannello sono generici: ulteriori affinamenti possibili per ogni effetto.

### Note di build/esecuzione
- Target: `mainTappa16` (output in `build/bin`).