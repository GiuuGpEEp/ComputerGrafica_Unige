## Tappa 16 — Implementazione degli effetti mancanti

Di seguito gli effetti implementati/rifiniti e, per ciascuno, la descrizione funzionale e le modifiche ai file necessarie per ottenerne il comportamento.

### Effetti implementati/rifiniti 

- **La Melodia del Drago che si Risveglia**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 carta in mano da scartare e nel Deck almeno un Drago con ATK ≥ 3000 e DEF ≤ 2500.
		- Flusso P1 (umano): seleziona una carta in mano da scartare; si apre un pannello che mostra i Draghi 3000/2500 dal Deck da aggiungere alla mano. È possibile aggiungerne fino a 2 nella stessa risoluzione (il pannello resta aperto per la seconda scelta). ESC termina la selezione anticipatamente.
		- Flusso P2 (AI): scarta casualmente una carta dalla mano e sceglie casualmente fra i bersagli validi nel Deck.
		- UX: titolo specifico “Scegli un Mostro Drago dal Deck da aggiungere alla mano” e hint che indica la doppia scelta possibile.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp:
      - `requestHandDiscard(int ownerIdx)`: apre la scelta di scarto per l'owner, emettendo HandDiscardChoiceRequested (delegandoo); fallisce se la mano è vuota o già occupata da un'altra scelta.
      - `resolvePendingHandDiscard(size_t handIndex)`: scarta la carta selezionata dalla mano al Cimitero, chiude la scelta di scarto e, se pianificato, avvia la scelta dal Deck per Melodia.
      - `setMelodiaAddsRemaining(int n)`: imposta quante aggiunte dal Deck sono ancora possibili per la Melodia (fino a 2).
      - `setNextAddFromDeckAfterDiscard(int ownerIdx)`: pianifica che, al termine dello scarto, venga richiesta l'aggiunta dal Deck per lo stesso owner (emette DeckAddChoiceRequested).
      - `hasPendingAddFromDeck() const`: true se c'è una scelta di aggiunta dal Deck in corso. 
      - `resolvePendingAddFromDeck(size_t idx)`: aggiunge alla mano la carta selezionata dalla lista candidati; decrementa il contatore e, se rimangono scelte, riapre la lista; altrimenti chiude.

		- GameLogic/Game/Effects/cards/BluEyes/LaMelodiaDelDragoCheSiRisveglia/LaMelodiaDelDragoCheSiRisvegliaEffect.cpp
			- resolve(): requestHandDiscard(ownerIdx); setMelodiaAddsRemaining(2); setNextAddFromDeckAfterDiscard(ownerIdx).

		- Progetto/Tappa_16/AppHandlers/AppHandlers.cpp
			- Gestione HandDiscardChoiceRequested e DeckAddChoiceRequested: chiusura prompt risposta, apertura overlay con candidati, auto-pick AI, riuso overlay DeckSend.

		- Progetto/Tappa_16/main.cpp
			- Overlay riusato per l’aggiunta dal Deck: titolo/hint dedicati, persistenza per seconda scelta, conferma e chiusura condizionale.

		- Progetto/Tappa_16/Utils/RenderUtils.h
			- drawDeckSendOverlay(..., titleOverride, hintOverride) per personalizzare titolo e hint dell’overlay.

- **Richiamo del Posseduto (semplificato)**
	- Cosa fa
		- Attivabile se il proprietario ha almeno 1 Mostro nel proprio Cimitero e spazio disponibile in zona Mostri.
		- Flusso P1 (umano): si apre un pannello che mostra solo i Mostri nel Cimitero con titolo “Scegli il mostro da evocare”. Dopo la selezione, il Mostro viene Evocato Specialmente in Posizione di Attacco (scoperta).
		- Flusso P2 (AI): seleziona casualmente un Mostro dal Cimitero e lo evoca.
		- Nota: il “link” continuo classico (se la Trappola lascia il Terreno, distruggi quel Mostro) è pianificato come follow‑up e non implementato qui.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Game.h, Game.cpp
				- Flusso pendente per la scelta dal Cimitero:
					- requestSelectFromGraveyard(int ownerIdx): apre la scelta nel Cimitero dell'owner filtrando implicitamente ai Mostri; emette GraveyardChoiceRequested; fallisce se non ci sono Mostri.
					- resolvePendingSelectFromGraveyard(size_t indexInOwnerGY): prende il Mostro all'indice reale del Cimitero dell'owner, lo rimuove dal Cimitero e lo evoca specialmente scoperto in Posizione di Attacco; chiude la scelta.
					- cancelPendingSelectFromGraveyard(): annulla e chiude la scelta corrente dal Cimitero.
					- getPendingGraveyardOwner() const: restituisce l'owner della scelta Cimitero se presente.
					- hasPendingGraveyardChoice() const: true se è attiva una scelta dal Cimitero.
		- GameLogic/Events/EventDispatcher.h
			- Aggiunto GameEventType::GraveyardChoiceRequested per aprire la UI di scelta dal Cimitero.
		- GameLogic/Game/Effects/cards/BluEyes/RichiamoDelPosseduto/RichiamoDelPossedutoEffect.cpp
			- resolve(): sostituito l’auto-pick con requestSelectFromGraveyard(ownerIdx) per l’interazione.
		- Progetto/Tappa_16/AppHandlers/AppHandlers.h, AppHandlers.cpp
			- Context: aggiunto setDeckSendIndexMap(std::function<void(const std::vector<size_t>&)>).
			- Handler GraveyardChoiceRequested: P2 (AI) auto-pick tra i Mostri; P1 (umano) apertura overlay con candidati filtrati ai soli Mostri e mappatura indici UI → indici reali nel Cimitero.
		- Progetto/Tappa_16/GameWiring/GameWiring.h, GameWiring.cpp
			- setupAppHandlers(...): estesa la firma per ricevere e cablare setDeckSendIndexMap nel Context.
		- Progetto/Tappa_16/main.cpp
		- Overlay riusato anche per il Cimitero; introdotto deckSendIndexMap per mappare la selezione sull’indice reale nel Cimitero.
		- Conferma: se hasPendingGraveyardChoice(), mappa l'indice UI → indice reale tramite deckSendIndexMap e poi chiama resolvePendingSelectFromGraveyard(mapped).
			- Titolo dell’overlay: “Scegli il mostro da evocare”.

- **Rivali Predestinati (semplificato)**
	- Cosa fa
		- Applica una negazione a durata turno secondo le regole semplificate del progetto; integrato nel sistema di attivazioni/chain.
	- Cosa è stato aggiunto/modificato nei file
		- GameLogic/Game/Effects/cards/BluEyes/RivaliPredestinati/RivaliPredestinatiEffect.cpp
			- Effetto registrato come attivazione e applicazione della negazione via helper sul Game.
		- GameLogic/Game/Game.h, Game.cpp
			- Helper/flag per tenere traccia della negazione a durata turno e verifiche negli hook opportuni.

### Altre modifiche di sistema e UX
- Prompt di risposta/chain (dalla Tappa 15, rifinito): apertura su eventi rilevanti, mostra solo ST attivabili del giocatore locale (P1), e viene chiuso prima dei pannelli modali. La chain risolve LIFO; ESC effettua pass locale e, in demo, auto-pass dell’AI.
- Regola M/T: attivazione dalla zona M/T consentita solo se la carta è settata (faccia in giù). Previene ri‑prompts per Trappole Continue già scoperte.
- Rendering mano: texture fronte garantite e mantenimento della dimensione originale dopo lo swap di texture.
- Overlay unificato (Deck/Cimitero): riuso con title/hint contestuali e mappatura indici quando la lista è filtrata.

### Controlli rapidi
- Overlay di scelta (Deck/Cimitero): Invio = Conferma, ESC = Annulla/Termina, Frecce o Click = Cambia selezione.
- Scarto dalla mano (Melodia): clic sulla carta in mano richiesta.
- Prompt di risposta (chain): selezione carta attivabile e conferma; ESC passa la priorità.

### Comportamento dell’AI (P2)
- Scelte casuali per: scarto carta mano (Melodia), aggiunta dal Deck (Melodia), invio/ricerca dal Deck dove previsto, selezione dal Cimitero (Richiamo).

### Limitazioni e prossimi passi
- Richiamo del Posseduto: non implementato (in questa tappa) il legame continuo con il Mostro evocato.
- Alcuni testi/hint del pannello sono generici: ulteriori affinamenti possibili per ogni effetto.

### Note di build/esecuzione
- Target: `mainTappa16` (output in `build/bin`).