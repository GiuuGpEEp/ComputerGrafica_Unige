**Tappa 13 – Magie e Trappole (engine + UI + build)**

Questa tappa introduce il sistema di Magie/Trappole (M/T): zone dedicate, slot Magia Terreno, regole di set/attivazione, eventi e API del `Game`.

## Obiettivi
- Zone M/T per entrambi i giocatori con 3 slot ciascuna.
- Slot esclusivo per Magia Terreno per ogni giocatore (sostituzione invia la precedente al Cimitero).
- Regole di attivazione conformi al minimo richiesto:
	- Trappole: non si attivano dalla mano; vanno settate; non attivabili nel turno in cui sono state settate; (prossimo step) attivabili nel turno avversario.
	- Magie Normali/Rituali: attivabili dalla mano; possono anche essere settate e attivate subito.
	- Magie Rapide: attivabili dalla mano; se settate non attivabili nello stesso turno; (prossimo step) utilizzabili nel turno avversario.
	- Magie Continue: restano sul campo dopo l’attivazione.
	- Magie Terreno: vanno nello slot dedicato e restano attive.

## Cambi principali al codice

### Game
File: `GameLogic/Game/Game.h` e `GameLogic/Game/Game.cpp`.

- Nuove zone e stato:
	- `spellTraps[2]`: carte M/T sul campo (3 slot per giocatore).
	- `stIsFaceDown[2]`: true se la carta M/T nello slot è coperta.
	- `stSetThisTurn[2]`: true se la carta è stata settata in questo turno del proprietario (vincolo di timing).
	- `fieldSpell[2]`: slot opzionale per Magia Terreno (una per giocatore).
- Nuove API M/T:
	- `bool setSpellOrTrap(size_t handIndex);`
	- `bool setFieldSpell(size_t handIndex);`
	- `bool activateSpellFromHand(size_t handIndex);` (blocca Trappole dalla mano; Continue restano sul campo; Terreno usa slot dedicato)
	- `bool activateSetSpellTrap(size_t zoneIndex);` (blocca attivazione nello stesso turno del set per Trappole e Rapide)
	- Query: `isSpellTrapFaceDownAt`, `isSpellTrapSetThisTurnAt`.
- Integrazione turno/fasi:
	- In `startTurn()` si azzera `stSetThisTurn` per il giocatore precedente (quello che ha appena concluso il turno), così una Trap/Magia Rapida settata nel proprio turno diventa attivabile già nel turno successivo dell’avversario.
- `moveCard(...)` esteso a `SpellTrapZone` con mantenimento dei flag e blocco su `FieldSpellZone` (usa API dedicate).

### Eventi
File: `GameLogic/Events/EventDispatcher.h`.

- Aggiunti tipi evento per M/T:
	- `SpellSet`, `TrapSet`, `SpellActivated`, `TrapActivated`.
	- Eventi esistenti riutilizzati: `CardMoved`, `CardSentToGrave`.

## API aggiunte:
- `bool setSpellOrTrap(size_t handIndex);`
- `bool setFieldSpell(size_t handIndex);`
- `bool activateSpellFromHand(size_t handIndex);`
- `bool activateSetSpellTrap(size_t zoneIndex);`
 - `bool isSpellTrapFaceDownAt(int playerIdx, size_t zoneIndex) const;`
- `bool isSpellTrapSetThisTurnAt(int playerIdx, size_t zoneIndex) const;`
 - `std::optional<Card> getFieldSpellOf(int playerIdx) const;` (getter per lo slot Campo)

## UI e controlli
- Trascinamento dalla mano:
	- Se la carta è Magia/Trappola: trascina su zona M/T o slot Campo → appare un prompt “Magia/Trappola: A = Attiva, S = Setta”.
		- A = attiva dalla mano (le Field vanno nello slot Campo; le Trappole non si possono attivare dalla mano).
		- S = setta coperta (Trappole sempre; Rapide settate non attivabili nello stesso turno; Field va nello slot Campo e rimpiazza la precedente mandandola al Cimitero).
	- Se la carta è un Mostro: trascina su uno slot Mostro → “E = Evoca, P = Posiziona”. L’azione userà lo slot indicato dal drop.
- Attivazione da coperta:
	- Premi X con il mouse sopra una tua carta coperta nella zona M/T per tentare l’attivazione (`activateSetSpellTrap`).
- Altri controlli:
	- C = cambia posizione del mostro selezionato secondo le regole (flip da coperta a scoper­ta in ATK, ATK↔DEF con limiti di turno).
- Note di rendering:
	- Le carte M/T coperte usano la texture retro, le scoperte usano `Card::originalTexturePath`.
	- I Mostri mantengono lo slot visivo assegnato anche dopo distruzioni di altre carte (niente più shift a sinistra).
	- Lo slot Campo mostra la Field Spell attiva per ciascun giocatore.

### Altre modifiche in Game

- Timing set/attivazione M/T: reset `stSetThisTurn` cambiato
	- Modifica: in `startTurn()` si pulisce `stSetThisTurn` del giocatore precedente, non quello corrente.
	- Motivo: rendere attivabili Trap/Magie Rapide settate nel proprio turno già dal turno avversario successivo.

- Modifica dell'attivazione delle magie e trappola posizionate :
	- `bool activateSetSpellTrap(size_t zoneIndex);`
		- Alias per il giocatore di turno; inoltra a `activateSetSpellTrapFor(cur, zoneIndex)`.
	- `bool activateSetSpellTrapFor(int playerIdx, size_t zoneIndex);`
		- Attiva una M/T settata per un giocatore assoluto (0/1). Regole:
			- Proprio turno: solo in Main1/Main2; se `stSetThisTurn==true` e (Trap o Magia Rapida) → non attivabile.
			- Turno avversario: solo Trap o Magie Rapide; se `stSetThisTurn==true` → non attivabile.
		- Flusso: `canActivate` dell’effetto, scoperta carta (`stIsFaceDown=false`), evento `TrapActivated`/`SpellActivated`, risoluzione; se non-Continua, invio al Cimitero con rimozione voci parallele.
	- `bool canActivateSetSpellTrapFor(int playerIdx, size_t zoneIndex);`
		- Controllo a secco con lo stesso gating di cui sopra.
	- Query: `isSpellTrapFaceDownAt`, `isSpellTrapSetThisTurnAt`.

- Stato e flag M/T:
	- `spellTraps[2]`: zona M/T per giocatore.
	- `stIsFaceDown[2]`: copertura M/T.
	- `stSetThisTurn[2]`: marcatura di set nel turno del proprietario; sblocco dal turno successivo via reset in `startTurn()`.
	- `fieldSpell[2]`: slot Field Spell.

- Allineamento strutture:
	- `moveCard(...)`: quando si rimuove/aggiunge in `SpellTrapZone`, si mantengono allineati `stIsFaceDown` e `stSetThisTurn`.

- Eventi:
	- Emessi `TrapActivated`/`SpellActivated` all’attivazione; `CardSentToGrave` quando la carta non-Continua va al Cimitero.

- Scelte effetto (infrastruttura):
	- Special Summon con scelta posizione: `requestSpecialSummonWithChoice`, `resolvePendingSpecialSummon`; evento `SpecialSummonChoiceRequested` e stato `pendingSS`.
	- Invio dal Deck: `requestSendFromDeck`, `resolvePendingSendFromDeck`, `cancelPendingSendFromDeck`; evento `DeckSendChoiceRequested` e stato `pendingSend`.
	- Mirroring Deck UI: `mirrorExternalDeckRemoveByName` per allineare la pila visiva quando il Deck logico viene modificato da effetti.

- Altri flag (rilevanti per regole):
	- `monsterHasAttacked`, `monsterIsDefense`, `monsterIsFaceDown`, `monsterSummonedThisTurn`, `monsterPositionChangedThisTurn`.


### Progetto/Tappa_13/main.cpp

- Prompt di risposta (turno avversario) per Trap/Magie Rapide:
	- Stato: `responsePromptActive`, `responseOwner` (0/1), `responseActivables` (lista attivabili), `responseSelected` (indice selezione).
	- Apertura automatica su finestre di timing base (TurnStart, avanzamenti fase, AttackDeclared) con rebuild lista via `canActivateSetSpellTrapFor`.
	- Navigazione: frecce su/giù; Invio per attivare (chiama `activateSetSpellTrapFor`); ESC per chiudere.
	- Modal: mentre è aperto vengono bloccati avanzamenti fase, attacchi, drag&drop, toggle posizione, attivazioni rapide e input pending; annulla drag corrente all’apertura.
	- Aggiornamento live: alla ricezione di `SpellActivated`/`TrapActivated` si ricostruisce la lista; se vuota, chiude.

- Hotkey e gating:
	- `X` per attivazioni da coperta nel proprio turno; tutte le azioni soggette a guardia `!responsePromptActive`.

Motivo: UX coerente e davvero modale quando esiste una finestra di risposta.

### Progetto/Tappa_13/Deck/Deck.h e Deck/Deck.cpp

- Utilità per rimozione/ricerca dal Deck:
	- `removeFirstByName`, `findFirst`, `collectWhere` per supportare overlay e risoluzioni effetto.

- Coerenza visiva:
	- `resetDeckCardPositions` riallinea pila e texture retro; `resetAnimation` per ri-fade.
	- Shuffle avanzato: `startShuffleAnimationAdvanced`, `updateShuffleAnimationAdvanced`, `drawShuffleAnimationAdvanced`, `clearShuffleAnimationAdvanced`, `isShuffleAnimationAdvancedFinished`.

Motivo: supporto a effetti deck-driven e UI consistente.

### Bugfix e rifiniture

- Battaglia: marcatura “ha attaccato” all’inizio della dichiarazione per evitare blocchi quando il primo attaccante si autodistrugge.
- Cache M/T: pulizia su reset/nuova partita per evitare texture residue dopo rientri.

### Stabilità slot Mostri e scelta esplicita dello slot (slot-aware)

Problema
- I Mostri “scivolavano” verso sinistra dopo una distruzione perché il rendering usava l’indice nel vettore della zona (che si compatta su erase) invece dello slot della plancia.

Soluzione implementata
- Introdotta una mappatura per-slot separata che stabilizza il posizionamento visivo:
	- `std::array<std::vector<int>,2> monsterSlotIndex;` mappa, per ciascun giocatore, ogni carta nella Monster Zone al suo indice di slot [0..2].
	- La mappa viene impostata all’ingresso (Evoca/Posiziona/Special Summon) e pulita all’uscita (distruzione/Tribute/spostamento zona).
- API di Evocazione/Posizionamento con slot esplicito:
	- `bool tryNormalSummonToSlot(size_t handIndex, size_t slotIndex);`
	- `bool tryNormalSetToSlot(size_t handIndex, size_t slotIndex);`
	- Tribute flow conserva la scelta: `beginNormalSummonWithTributes(size_t handIndex, bool asSet, std::optional<size_t> slotIndexOpt);` e assegna lo slot in `completePendingNormalSummon()`.
- Query/Helper:
	- `int getMonsterSlotIndexAt(int playerIdx, size_t zoneIndex) const;`
	- `bool isMonsterSlotOccupied(int playerIdx, size_t slotIndex) const;`
	- `std::optional<size_t> firstFreeMonsterSlot(int playerIdx) const;`

Integrazione UI
- Rilevazione slot sotto il mouse: `findMonsterSlotIndexUnderMouse(...)` restituisce l’indice slot libero puntato.
- Drag&drop Mostri: alla conferma “E/P” si chiama l’API slot-aware se è stato identificato lo slot; in fallback usa il primo slot libero.
- Rendering: sincronizzazione che posiziona i Mostri leggendo `getMonsterSlotIndexAt(...)`, non più per indice di vettore.
- Occupancy: gli slot di plancia sono marcati occupati/liberi durante la sync per impedire drop su slot già occupati.

Risultato
- Nessun riordino visivo dei Mostri dopo distruzioni; l’Evocazione/Posizionamento rispetta lo slot indicato dal giocatore.

Next
- Special Summon: attualmente assegna il primo slot libero; previsto overlay di scelta slot per uniformità UX.


## Aggiornamenti recenti (26/08/2025) — pescata alternata, animazioni draw, fix P2 e UX

Questa sezione riassume gli ultimi miglioramenti a pesca iniziale, animazioni di pescata, rendering lato avversario e piccoli affinamenti UX/engine.

### Apertura: pescata alternata 1–a–1 fino a 5 carte
- Comportamento: all’inizio della partita P1 e P2 pescano in modo alternato (P1, P2, P1, P2, …) fino a raggiungere 5 carte ciascuno.
- Implementazione: la logica è stata spostata fuori da `Game::start()` e orchestrata nel loop principale, una pescata per volta, attendendo il completamento dell’animazione.
- Salvaguardia engine: in `Game::startTurn()` è presente una guardia che evita doppie pescate a 5 carte se la mano è già stata riempita dall’apertura.
- UX: l’AI del Player 2 avanza solo quando non ci sono animazioni di pescata in corso (evita salti di fase durante l’apertura).

Motivazione: ottenere un’apertura più “televisiva” e chiara, con temporizzazione coerente e senza overdraw.

### Animazioni di pescata differenziate (P1 vs P2)
- P1 (giocatore locale): la carta pescata viene mostrata al centro della scena con la sua texture frontale per alcuni secondi (PAUSE_DURATION). È possibile saltare l’attesa cliccando (mousePressed), portando subito la carta in mano.
- P2 (avversario): niente rivelazione. La carta si muove direttamente dal Deck alla mano superiore con la texture di retro (coperta).
- Dettagli tecnici: il controller passa due flag all’animazione — `mousePressed` (skip dell’attesa al centro) e `forceSkipReveal` (salta la rivelazione al centro). L’animazione usa `skipPause` (per il click) e `skipCenterReveal` (per P2) per scegliere il percorso.

Motivazione: rispettare la regola di non rivelare le pescate avversarie, mantenendo al contempo un feedback visivo ricco per P1 e il controllo “click-to-skip”.

### Fix rendering e visibilità lato P2
- Mano e Deck P2 sempre visibili nei momenti corretti (incluso post-shuffle); il Deck non “scompare” durante l’animazione di mescolamento.
- Texture/rotazioni corrette: carte coperte con texture di retro, mano superiore ruotata a 180°, mostri in DEF/face-down con orientamento giusto.
- Allineamento slot P2: le carte non finiscono in zone sbagliate (es. Mostri nella zona M/T) grazie alla stabilizzazione per-slot già descritta.

Motivazione: coerenza visiva e chiarezza per il secondo giocatore.

### Note su eventi e gating
- Emissione `DrawStart`/`DrawEnd` attorno alle animazioni per sincronizzare UI/AI.
- L’AI del Player 2 viene aggiornato solo quando il controller di pescata è idle.

### Game Over e condizioni di vittoria (sintesi)
- Condizioni: sconfitta per LP ≤ 0 o per esaurimento del Deck (draw fail). È presente un overlay di Game Over con esito e rientro al flusso principale.

Motivazione: completare il ciclo di gioco con un esito chiaro e un rientro controllato all’interfaccia.

## AIController (Player 2) — struttura, flusso e integrazione

Scopo: fornire un avversario base per il Player 2 che giochi turni autonomi rispettando le regole minime del motore (summon base, magie dalla mano, set M/T, attacchi semplici).

File: `GameLogic/AI/AIController.h`, `GameLogic/AI/AIController.cpp`.

### Struttura e responsabilità
- Costruzione: `explicit AIController(int aiPlayerIdx = 1)` — per default controlla il giocatore 1 (indice 1, il lato alto).
- Collegamento al gioco: `attachGame(Game* g)` — memorizza il puntatore e resetta lo stato di fase.
- Tick: `update(float dt)` — invocato nel main loop solo quando non ci sono animazioni di pescata in corso; opera esclusivamente se è il turno dell’AI.
- Stato interno anti-spam:
	- `lastTurnCount_`, `lastPhase_`: per rilevare il cambio di fase/turno.
	- `actedInThisPhase_`: assicura una sola azione significativa per fase; il resto del flusso (avanzamento) è demandato a `Game`.

### Policy per fase (semplificata)
- Draw: l’AI non fa nulla; la pescata è gestita dal `DrawController` nel layer esterno, quindi `Game::advancePhase()` viene chiamato subito.
- Standby: salto implicito gestito dal motore; nessuna azione diretta.
- Main1 (`doMain1`):
	1) Evoca un mostro di livello ≤ 4 nel primo slot Mostri libero (usa la mappatura di slot stabile del motore).
	2) In alternativa, prova ad attivare una Magia dalla mano via `Game::activateSpellFromHand` (il motore blocca Trappole dalla mano).
- Battle (`doBattle`): dichiara attacchi con tutti i mostri che non hanno già attaccato; bersaglio preferito tra i mostri avversari con ATK più basso, altrimenti attacco diretto.
- Main2 (`doMain2`): setta Field Spell, poi Trap/Magie Rapide dalla mano se possibile.
- End: se non ci sono scarti forzati od altre attese modali, chiude il turno.

Helper principali:
- `findFirstFreeMonsterSlot()`: calcola gli slot Mostro liberi usando la mappa per-slot del motore (evita riordini visivi).
- `pickSummonFromHand()`: seleziona il primo mostro evocabile (<= 4 stelle).
- `pickNormalSpellFromHand()`: seleziona una carta Magia/Trappola/Field dalla mano; l’effettivo gating è delegato a `Game`.
- `trySetTrapsAndQuick()`: setta Field, poi M/T dalla mano rispettando le regole.
- `pickBestAttackTarget()`: ritorna l’indice del mostro avversario con ATK più basso; `std::nullopt` per attacco diretto.

### Integrazione nel main loop e gating
- In `main.cpp`, l’AI viene aggiornata solo quando `drawController.idle()` è true, così da non sovrapporsi alle animazioni di pescata e non avanzare le fasi prima del tempo.
- Durante l’apertura a pescata alternata, l’AI resta in attesa finché la mano non è completa.
- Alcune azioni sono comunque soggette ai guard-rail del motore (turno/phase check, `hasMonsterAlreadyAttacked`, regole M/T, ecc.).

Motivazioni progettuali:
- Tenere l’intelligenza “sottile”: le regole sono centralizzate in `Game`; l’AI propone azioni “lecite” ma non duplica la logica di validazione.
- Evitare comportamenti frenetici: un’azione per fase e avanzamento pilota demandato a `Game` per un flusso deterministico e debuggabile.

