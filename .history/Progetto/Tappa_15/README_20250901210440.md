## Tappa 15 — Changelog delle modifiche funzionali

Dopo aver sistemato un minimo il codice, in questa tappa cerco di fixare tutte le problematiche individuate all'interno del gioco fin'ora, e successivamente di implementare una prima bozza di EffectChain

## Risoluzione Sincronizzazione del deck
Spesso capitava che usando degli effetti che modificano il numero di carte nel deck, quest'ultimi funzionassero anche se la carta scelta non era più presente all'interno del deck stesso.
Ho quindi fatto in modo di sincronizzare correttamente il deck, con tutte le modifiche che gli vengono fatte:

**Modifiche principali**

- `Player` adesso memorizza un puntatore al proprio `Deck` invece di copiarne il contenuto.
  - Scopo: evitare copie accidentali del Deck che causavano differenze tra logica e UI.

- `Game` modifica del metodo per associare il deck al gioco:
  - `attachExternalDeck(Deck*, int)` adesso non prende più come parametro solo il puntatore a deck, ma anche l'indice del player, in modo da non rischiare di avere un unico puntatore per 2 deck.
  - Internamente `Game` conserva `externalDecks[2]` (un array con 2 puntatori a oggetti Deck differenti).
  - `Game::mirrorExternalDeckRemoveByName(const std::string&, const Deck*)` adesso riceve il `sourceDeck` per evitare "double-remove" quando la sorgente della rimozione è già la stessa istanza grafica.
  - Decisione sul deck-out, la condizione di deck-out ora usa lo stato logico del gioco (es. `current().canDraw()`), non lo stato visivo dell'UI.
  - Questo evita vittorie errate dovute a disallineamenti temporanei tra UI e logica.

- `Overlays` (Graveyard / ExtraDeck)
  - Implementata funzione `reset()` che pulisce cache interne, selezioni e bounding boxes.
  - `main.cpp` è stato aggiornato per chiamare i `reset()` appropriati durante `resetMatch` (prima e dopo la ricreazione dei Deck) per evitare residui grafici tra le partite.


- Aggiornamento anche dei file che chiamano i metodi modificati:
  - `GameWiring` ora registra effetti di default, attacca i Deck esterni (`attachExternalDeck`) e collega il `DrawController` al `Game`.
  - `AppHandlers` è stato aggiornato per usare i nuovi hook di sincronizzazione (event handlers: DrawStart/DrawEnd, NormalSummon, CardMoved, ecc.).
  - `main.cpp` aggiorna `resetMatch` per ricreare deck e resettare overlay in modo sicuro.

**File principali modificati**
- `GameLogic/Player/Player.h` — Player ora contiene `Deck*` non-owning.
- `GameLogic/Game/Game.h` / `Game.cpp` — `externalDecks`, `attachExternalDeck`, `mirrorExternalDeckRemoveByName`, deck-out logic.
- `GameLogic/DrawController/DrawController.cpp` — gestione animazioni pesca e `reset()`.
- `GraveyardOverlay/*`, `ExtraDeckOverlay/*` — stato `reset()` per cancellare cache UI.
- `GameWiring/GameWiring.cpp` — inizializzazione effetti, attach deck/draw controller.
- `AppHandlers/AppHandlers.cpp` — wiring degli eventi verso le callback UI.
- `main.cpp` — `resetMatch` aggiornato per ricreare deck, resettare overlay e riallocare le risorse necessarie.

## Modifica Drag ed Evocazioni Tributo

Ho modificato la logica di drag per far si che una volta scelto lo slot la carta torni in mano per poi evocarla, in modo tale che nelle evocazioni tramite tributo la carta non resti in mezzo rendendo difficile la selezione dei tributi:

- Drag/Tribute 
  - Quando si rilascia una carta della mano su campo e parte la procedura di evocazione (Evoca/Posiziona), la carta non rimane più "flottante" al centro: il codice ora richiama un callback `cancelActiveDrag()` che riporta immediatamente la carta nella mano --> callback creata nel main e passata al nostro `Contex`, oppure usata nel main stesso
  - Se la carta viene rilasciata fuori da uno slot valido, la carta torna immediatamente in mano (comportamento già presente: `cardBackToHand`).

- InputController
  - `InputController` ora gestisce `E`/`P`/`A`/`S` come prima, ma con ulteriori protezioni:
    - Se l'utente preme `E` mentre è in drag senza una scelta Evoca/Posiziona attiva, il drag viene annullato e la carta ritorna in mano.

- Highlight per tributi
  - Le carte sul campo che sono state selezionate come tributi ricevono un leggero tint (medesimo effetto visivo usato per la selezione di un attaccante). Questo aiuta l'utente a distinguere i mostri scelti durante la procedura di tributo --> aspetto gestito in `drawMonsterCard` in `RenderUtils` 

## Modifica del discard delle carte nel cimitero - e reset

Breve riassunto delle modifiche fatte per risolvere un problema segnalato dove le carte scartate da P2 finivano nel cimitero di P1 e, successivamente, per allineare le animazioni alla logica:

- Problema risolto: quando un giocatore scartava, le carte venivano talvolta inserite nel `graveyard` del giocatore sbagliato (logica). Ho quindi aggiunto un getter che permette di accedere al graveyard in base al proprietario e modificato anche le animazioni per lo scarto delle carte.
- Animazioni: dopo la correzione della logica, l'animazione risultava invertita (visivamente puntava al lato opposto). La causa era una convenzione diversa tra il `Game` (owner index 0/1) e `Field::getSlotPosition` (player convention 1/2). Ho aggiunto il mapping appropriato quando si calcola la posizione visiva del graveyard.

File toccati (principali)
- `GameLogic/Game/Game.h` / `Game.cpp` — aggiunto `getGraveyardOf(int)` e reso `getGraveyard()` dipendente dal turno corrente.
- `GameLogic/DiscardController/DiscardController.h` / `DiscardController.cpp` — `start(..., int ownerIdx, ...)` ora riceve e memorizza il proprietario; alla fine dell'animazione inserisce le carte nel graveyard del proprietario.
- `GameWiring/GameWiring.cpp` — la callback che avvia l'animazione ora:
  - legge `ownerIdx = game->getTurn().getCurrentPlayerIndex()` (0/1), memorizzando l'indice dell'owner
  - calcola `fieldPlayer = ownerIdx + 1` per `Field::getSlotPosition` --> al posto che passagli 0/1 gli passo 1 o 2 perchè è come avevo salvato i giocatori
  - chiama `discardController.start(std::move(excess), gyCenter, ownerIdx)`.
- `main.cpp` (piccola correzione) — evitato il richiamo prematuro a `onDiscardAnimationFinished()` e migliorato il timing di fine-animazione.

**Altro problema -->** ogni tanto dopo aver finito una partita, se ne iniziavamo un altra poteva capitare che in mezzo al campo fosse presente una carta, che successivamente finiva nel cimitero. Questa probabilmente era un residuo della partita precedente, per risolvere ho fatto questo:
 - Aggiunta all'interno di discardController un `DiscardController::reset()` e implementato per svuotare eventuali animazioni/pending di scarto; ciò evita che sprite/carte residue dalla partita precedente rimangano vicino al cimitero alla creazione di una nuova partita.
 - `GameLogic/DiscardController/DiscardController.h` / `DiscardController.cpp` — aggiunto `reset()`; `main.cpp` ora chiama `discardController.reset()` in `resetMatch` e subito dopo la ricreazione dei deck per evitare residui visivi/animazioni tra partite.


## Modifica degli Effetti carte
- Gli effect handlers delle carte `Pietra bianca della leggenda` e `pietra bianca degli antichi` sono stati adattati per chiamare `mirrorExternalDeckRemoveByName(...)` passando il puntatore al deck sorgente, così da mantenere sincronizzate il numero di carte del deck con gli effetti chiamati Deck UI senza double-remove.

- Correzione effetto `Pietra bianca della leggenda`:
	- Quando l'effetto di "Pietra Bianca della Leggenda" aggiungeva un "Drago Bianco Occhi Blu" dal Deck alla mano, la carta appariva con la texture del retro perché il percorso effetto bypassava il `DrawController` (che normalmente applica la texture frontale). Per risolvere il problema adesso `WhiteStoneLegendEffect` riceve un riferimento a `TextureManager` e chiama `RenderUtils::applyFrontTextureIfAny(...)` prima di aggiungere la carta alla mano. Questo garantisce che la carta inserita dalla logica dell'effetto abbia la texture frontale corretta. Il passaggio di Texture avviene tramite `GameWiring`/`main.cpp` --> ho quindi aggiornato il metodo `registerDefaultEffects()` in `GameWiring`, chiamato da `createGameAndAttachResources`.
 
- Comportamento `Pietra bianca degli antichi` (Evocazione Speciale con scelta posizione): 
  - Flusso originale: l'effetto rimuove dal Deck un "Drago Bianco Occhi Blu" e chiama `Game::requestSpecialSummonWithChoice(ownerIdx, card)`. Questo registra una `pendingSS` e emette l'evento `SpecialSummonChoiceRequested`.
  - Modifica introdotta in Game e nell'effetto: l'effetto ora registra il trigger in modo robusto rispetto a chi sia il giocatore di turno. In particolare la Pietra viene considerata "pending" per la End Phase del turno in cui viene mandata al cimitero, indipendentemente da chi sia il giocatore corrente quando l'evento viene emesso. Per farlo il codice determina il proprietario reale controllando quale graveyard ha ricevuto la carta (fallback a `lastSentToGrave.ownerIdx` se necessario) e imposta `pendingThisTurn/ownerIdx` di conseguenza.
    - Ho inoltre aggiunto `Game::getPendingSpecialSummonOwner()` per semplificare l'ottenimento del proprietario della pietra.
    - Questo garantisce che l'effetto si attivi nella End Phase del turno in cui la Pietra è stata mandata al cimitero (es.: se la Pietra viene mandata al cimitero durante l'End Phase dell'avversario, si attiverà in quella stessa End Phase), evocando il BEWD sul terreno del proprietario della Pietra.

  - Aggiornamento della logica `AppHandlers` in risposta all'evento `SpecialSummonChoiceRequested`:
 		- Se il proprietario è il giocatore umano (P1): viene mostrato il prompt per scegliere Attacco o Difesa (`ctx.setSsChoiceActive(true)`).
 		- Se il proprietario è il giocatore AI (P2) l'AI risolve automaticamente la scelta senza aprire il prompt. In questa implementazione l'AI seleziona autonomamente Attacco o Difesa con una scelta casuale ( aggiunta della libreria random e della variabile _apphandlers_rand in `AppHandlers`).
	Quindi l'effetto chiama la funzione definita in Game, che genererà un evento di tipo SpecialSummonChoiceRequested, e verrà gestito dall'HandleDispatcher	
 
- Comportamento `Reliquiario del Drago` (Deck send choice): 
    - Scopo: quando il Reliquiario viene attivato, il giocatore sceglie un Drago dal proprio Deck da mandare al Cimitero, e poi il Reliquiario viene mandato nel Cimitero.
    - Comportamento introdotto:
      - Se il proprietario è il giocatore umano (P1): si apre il pannello `DeckSendChoice` e il giocatore sceglie manualmente quale Drago mandare al Cimitero (stesso flusso UI di prima).
      - Se il proprietario è il giocatore AI (P2): il pannello non viene mostrato; l'AI seleziona autonomamente una carta Drago dal suo Deck e la manda al Cimitero senza intervento UI.
    - Dettagli tecnici:
      - Aggiunto `Game::getPendingSendOwner()` per conoscere il proprietario della richiesta `requestSendFromDeck`.
      - In `AppHandlers`, il listener per `GameEventType::DeckSendChoiceRequested` ora:
        - se owner==1 (AI) raccoglie i candidati (carte Drago) e risolve automaticamente scegliendo un indice (implementazione corrente: scelta casuale tramite `_apphandlers_rand`) chiamando `resolvePendingSendFromDeck(index)`;
        - se owner==0 (umano) apre il pannello e passa i candidati a `ctx.setDeckSendCandidates` come prima.
      - Dopo che la carta Drago è mandata al Cimitero con `resolvePendingSendFromDeck`, Reliquiario stesso viene spostato dalla Spell/Trap Zone al Cimitero 
    Quindi quando viene attivata la magia l'effetto della carta (gestito nella cartella effects) richiama la funzione requestSendFromDeck in game, che scatenerà un evento di tipo DeckSendChoiceRequested e il seguito verrà gestito da AppHandlers

- Fix: `Pianto di Argento` aggiornato per usare `Game::getGraveyardOf(ownerIdx)`, questo garantisce che l'effetto cerchi il bersaglio nel cimitero del proprietario della carta.

**Miglioramento precisione della pietra**

- WhiteStoneAncients: siccome capitava spesso che si confondessi chi fosse l'effettivo proprietario della pietra mandata al cimitero ho migliorato la precisione con la quale si riesce a dedurre.
  - Ora il codice preferisce il valore registrato in `Game::lastSentToGrave.ownerIdx` (più affidabile) e lo valida controllando che il cimitero del proprietario contenga effettivamente la carta; solo se la validazione fallisce si esegue una scansione difensiva per nome in entrambi i cimiteri.
  - Questo risolve il bug in cui la Pietra veniva attribuita al giocatore che l'aveva distrutta (attack/destroy) anziché al suo controllore.

## Nuove Aggiunte: OverlayCimitero avversario


  Dettagli implementativi principali:
  - Ho aggiornato la struct `Input::Context` inserendo anche la posizione dello slot top (`graveyardSlotPosTop`) oltre a quello bottom, che viene passato dal main. Questo permette di distinguere quinidi i due slot. 
  - `InputController` gestisce la logica di hold su entrambi i rect (bottom/top), passati dal main. Se il mouse è dentro lo slot top passa `owner=1`, se è dentro lo slot bottom passa `owner=0`.
  - `GraveyardOverlay::startHold(...)` ora riceve anche l'`owner` e memorizza internamente `currentOwner` quando apre l'overlay; ciò permette a `draw(...)` di richiedere le carte corrette.
  - Durante il click/press `InputController` passa a `GraveyardOverlay::handleMousePress` il vettore di carte restituito da `game->getGraveyardOf(owner)` (fallback a `getGraveyard()` solo se `game` non è disponibile).
  - `main.cpp` è stato aggiornato in modo che, quando l'overlay è visibile, il `draw` usi `game->getGraveyardOf(graveyardOverlay.getCurrentOwner())` invece di mostrare sempre il graveyard del player bottom.

## Aggiornamenti recenti (sintesi)

Nelle ultime iterazioni ho introdotto e corretto alcune funzionalità UI e di input legate agli overlay (Extra / Graveyard) e alla visualizzazione dei dettagli delle carte. Qui sotto una sintesi rapida e le indicazioni per testare.

- Graveyard overlay 
  - Quando viene aperto l'overlay del cimitero relativo (bottom/top). L'overlay memorizza l'owner correntemente mostrato (`currentOwner`) e il `main` chiede le carte con `game->getGraveyardOf(owner)`.
- Click carte del graveyard 
  - Risolto un bug per cui cliccando una carta mostrata nell'overlay venivano letti i dettagli di un'altra carta: `GraveyardOverlay::handleMousePress` ora usa lo stesso ordinamento (`ordered`) usato da `draw()` per mappare coerentemente gli indici.
- Quando gli overlay sono aperti ho modificato il `main` per far si che non possano essere mostrati dettagli di altre carte che siano fuori dell'overlay stesso

- InputController
  - `InputController` è stato aggiornato per:
    - gestire hold/click per il graveyard top/bottom;
    - passare a `GraveyardOverlay::handleMousePress` il vettore di carte corretto (quello dell'owner mostrato) per evitare mismatch logici.


## Effect Chain e Prompt di Risposta (Quick/Trap)

In questa tappa è stata introdotta una prima bozza implementazione di una catena di effetti (Effect Chain) con finestra di risposta interattiva. 
**Cos'è e come funziona un'effect chain?** --> fino ad ora abbiamo lavorato con un effetto per volta, in realtà quando si attiva un effetto è possibile "mettere in catena" degli effetti rapidi, per poter concatenare degli effetti, oppure se necessario, rispondere all'attivazione di altri effetti. 
Obiettivo: prima che un effetto si risolva, deve comparire il prompt che chiede se attivare un altro effetto (se attivabile); se nessuno risponde, si risolve l’effetto. Se qualcuno risponde, si forma una catena e gli effetti si risolvono LIFO (ultimo attivato, primo a risolversi).

Comportamento principale
- Adesso quando attivo delle carte dalla mano non viene chiamatao subito risolve. Prima di risolvere il loro effetto infatti vengono aggiunte alla catena con `startChainWithActivation(...)` (aggiunge un elemento al vector di effetti) e la carta viene spostata nel Cimitero; la risoluzione avviene quando la catena si chiude.
- Attivazioni di carte settate (Trap/Quick): quando attivate, vengono aggiunte alla catena e (se non-continue) la carta viene spostata al Cimitero subito dopo l’attivazione, come da regola base.
- Quando non vengono aggiunti più effetti alla catena da entrambi i giocatori parte la risoluzione della catena stessa, che  è last in firs out.
- Modificato il prompt di risposta: Adesso dopo ogni giocata di mostro, cambio fase e attivazione effetti (eventi `SpellActivated`/`TrapActivated`) viene mostrato il prompt di risposta e mostra SOLO le carte attivabili del giocatore locale (P1), ossia Magie Rapide/Trappole che rispettano il timing.

Aggiunte di metodi
- Game
  - `startChainWithActivation(const std::string&, int)`: Marca la chain attiva e aggiunge un nuovo effetto al vector di effetti ovvero la catena 
  - `playerPassOnChain(int)`: registra il pass del giocatore; se passano entrambi consecutivamente (non aggiungono altri effetti), chainActive viene marcato come false e viene chiamato `EffectSystem::resolveAllActivations(...)` --> metodo della classe EffectSystem che si occupa di risolvere tutti gli effetti della catena
  - Modificato `activateSpellFromHand(...)`: per carte non-continue con `IActivationEffect`, al posto di chiamare il metodo `resolve()` per risolvere l'effetto usa invece `startChainWithActivation` e sposta la carta al Cimitero; niente `resolve()` immediato.

- EffectSystem
  - Aggiunta un `activationChain` (stack con tutte le `ActivationRequest`). 
  - `resolveAllActivations(Game&)` risolve dalla cima verso il basso chiamando tutti gli effetti chiamando `IActivationEffect::resolve(...)` nell’ordine inverso.
  - `pushActivationRequest()` 

- AppHandlers
  - Su `SpellActivated`/`TrapActivated`: aggiorna la UI e invoca l’apertura del prompt di risposta (`openResponsePromptIfAny`).
- UI (`main.cpp`)
  - `openResponsePromptIfAny`: imposta l’owner del prompt a P1 (0) e popola solo le sue attivazioni disponibili (`game->canActivateSetSpellTrapFor(0, i)`).
  - `confirmResponsePrompt(sel)`: attiva la carta selezionata ma NON chiude il prompt, permettendo ulteriori risposte; la catena chiuderà quando si passa.
  - `closeResponsePrompt`: interpretato come “pass” per P1; per ora esegue anche un auto-pass dell’avversario per far progredire/chiudere la chain (comportamento semplificato per test).
  - Se la chain è attiva e non ci sono risposte disponibili, viene eseguito auto-pass per entrambi così la chain si risolve subito.

Sequenza Reliquiario/Scelte UI
- Esempio: “Reliquiario del Drago” (scelta di un Drago dal Deck da mandare al Cimitero).
  - L’attivazione va in catena; la richiesta di scelta (`DeckSendChoiceRequested`) viene emessa SOLO quando la catena risolve l’effetto. Quindi la UI di scelta appare dopo la finestra di risposta.
  - Se l’owner è AI (P2), la selezione è automatica senza aprire la UI.

Come testare rapidamente
- Attiva una Magia non-continua con effetto di attivazione (es. Reliquiario):
  1) Vedi aprirsi il prompt prima della risoluzione.
  2) Premi ESC per passare → l’effetto si risolve (se nessun’altra risposta).
  3) Oppure premi INVIO su una tua Trap/Quick attivabile per aggiungere risposte alla catena. Ripeti finché vuoi, poi ESC per risolvere in LIFO.

Limitazioni note / next
- Prompt limitato al giocatore locale P1 (0). Per supportare P2 locale, introdurre un flag “local player index” e usarlo in `openResponsePromptIfAny`/pass.
- L’AI al momento passa automaticamente; per risposte più realistiche, implementare una politica di risposta (attivazione condizionale di Trap/Quick AI).

File toccati (aggiunte/variazioni rilevanti per la chain)
- `GameLogic/Game/Game.cpp` / `Game.h`: chain state (`chainActive`, `lastResponder`) e API (`startChainWithActivation`, `playerPassOnChain`, `isChainActive`); modifica attivazioni da mano.
- `GameLogic/Game/Effects/EffectSystem.*`: stack delle attivazioni e risoluzione LIFO.
- `AppHandlers/AppHandlers.cpp`: apertura prompt ad ogni attivazione.
- `main.cpp`: gestione prompt (solo P1), conferma che non chiude il prompt, ESC come pass, auto-pass per completare la risoluzione in questa versione.



