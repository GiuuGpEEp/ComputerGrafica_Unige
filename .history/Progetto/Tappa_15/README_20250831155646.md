## Tappa 15 — Changelog delle modifiche funzionali

Dopo aver sistemato un minimo il codice, in questa tappa cerco di fixare tutte le problematiche individuate all'interno del gioco fin'ora, e successivamente di implementare una prima bozza di EffectChain

## Risoluzione Sincronizzazione del deck
Spesso capitava che usando degli effetti che modificano il numero di carte nel deck, quest'ultimi funzionassero anche se la carta scelta non era più presente all'interno del deck stesso.
Ho quindi fatto in modo di sincronizzare correttamente il deck, con tutte le modifiche che gli vengono fatte:

**Modifiche principali**

- `Player` adesso memorizza un puntatore al proprio `Deck` invece di copiarne il contenuto.
  - Scopo: evitare copie accidentali del Deck che causavano differenze tra logica e UI.

- `Game` modifica del metodo per associare il deck al gioco:
  - `attachExternalDeck(Deck*, int)` adesso non prende più come parametro solo il puntatore a deck, ma anche l'indice del player, in modo da non rischiare di avere un unico puntatore per 2 deck.
  - Internamente `Game` conserva `externalDecks[2]` (un array con 2 puntatori a oggetti Deck differenti).
  - `Game::mirrorExternalDeckRemoveByName(const std::string&, const Deck*)` adesso riceve il `sourceDeck` per evitare "double-remove" quando la sorgente della rimozione è già la stessa istanza grafica.
  - Decisione sul deck-out, la condizione di deck-out ora usa lo stato logico del gioco (es. `current().canDraw()`), non lo stato visivo dell'UI.
  - Questo evita vittorie errate dovute a disallineamenti temporanei tra UI e logica.

- `Overlays` (Graveyard / ExtraDeck)
  - Implementata funzione `reset()` che pulisce cache interne, selezioni e bounding boxes.
  - `main.cpp` è stato aggiornato per chiamare i `reset()` appropriati durante `resetMatch` (prima e dopo la ricreazione dei Deck) per evitare residui grafici tra le partite.

- Aggiornamento anche dei file che chiamano i metodi modificati:
  - `GameWiring` ora registra effetti di default, attacca i Deck esterni (`attachExternalDeck`) e collega il `DrawController` al `Game`.
  - `AppHandlers` è stato aggiornato per usare i nuovi hook di sincronizzazione (event handlers: DrawStart/DrawEnd, NormalSummon, CardMoved, ecc.).
  - `main.cpp` aggiorna `resetMatch` per ricreare deck e resettare overlay in modo sicuro.

**File principali modificati**
- `GameLogic/Player/Player.h` — Player ora contiene `Deck*` non-owning.
- `GameLogic/Game/Game.h` / `Game.cpp` — `externalDecks`, `attachExternalDeck`, `mirrorExternalDeckRemoveByName`, deck-out logic.
- `GameLogic/DrawController/DrawController.cpp` — gestione animazioni pesca e `reset()`.
- `GraveyardOverlay/*`, `ExtraDeckOverlay/*` — stato `reset()` per cancellare cache UI.
- `GameWiring/GameWiring.cpp` — inizializzazione effetti, attach deck/draw controller.
- `AppHandlers/AppHandlers.cpp` — wiring degli eventi verso le callback UI.
- `main.cpp` — `resetMatch` aggiornato per ricreare deck, resettare overlay e riallocare le risorse necessarie.

## Modifica Drag ed Evocazioni Tributo

Ho modificato la logica di drag per far si che una volta scelto lo slot la carta torni in mano per poi evocarla, in modo tale che nelle evocazioni tramite tributo la carta non resti in mezzo rendendo difficile la selezione dei tributi:

- Drag/Tribute 
  - Quando si rilascia una carta della mano su campo e parte la procedura di evocazione (Evoca/Posiziona), la carta non rimane più "flottante" al centro: il codice ora richiama un callback `cancelActiveDrag()` che riporta immediatamente la carta nella mano --> callback creata nel main e passata al nostro `Contex`, oppure usata nel main stesso
  - Se la carta viene rilasciata fuori da uno slot valido, la carta torna immediatamente in mano (comportamento già presente: `cardBackToHand`).

- InputController
  - `InputController` ora gestisce `E`/`P`/`A`/`S` come prima, ma con ulteriori protezioni:
    - Se l'utente preme `E` mentre è in drag senza una scelta Evoca/Posiziona attiva, il drag viene annullato e la carta ritorna in mano.

- Highlight per tributi
  - Le carte sul campo che sono state selezionate come tributi ricevono un leggero tint (medesimo effetto visivo usato per la selezione di un attaccante). Questo aiuta l'utente a distinguere i mostri scelti durante la procedura di tributo --> aspetto gestito in `drawMonsterCard` in `RenderUtils` 

## Modifica del discard delle carte nel cimitero

Breve riassunto delle modifiche fatte per risolvere un problema segnalato dove le carte scartate da P2 finivano nel cimitero di P1 e, successivamente, per allineare le animazioni alla logica:

- Problema risolto: quando un giocatore scartava, le carte venivano talvolta inserite nel `graveyard` del giocatore sbagliato (logica). Ho quindi aggiunto un getter che permette di accedere al graveyard in base al proprietario e ho reso il controller delle animazioni .
- Animazioni: dopo la correzione della logica, l'animazione risultava invertita (visivamente puntava al lato opposto). La causa era una convenzione diversa tra il `Game` (owner index 0/1) e `Field::getSlotPosition` (player convention 1/2). Ho aggiunto il mapping appropriato quando si calcola la posizione visiva del graveyard.

File toccati (principali)
- `GameLogic/Game/Game.h` / `Game.cpp` — aggiunto `getGraveyardOf(int)` e reso `getGraveyard()` dipendente dal turno corrente.
- `GameLogic/DiscardController/DiscardController.h` / `DiscardController.cpp` — `start(..., int ownerIdx, ...)` ora riceve e memorizza il proprietario; alla fine dell'animazione committa le carte nel graveyard del proprietario.
- `GameWiring/GameWiring.cpp` — la callback che avvia l'animazione ora:
  - legge `ownerIdx = game->getTurn().getCurrentPlayerIndex()` (0/1),
  - calcola `fieldPlayer = ownerIdx + 1` per `Field::getSlotPosition` (convenzione 1/2),
  - chiama `discardController.start(std::move(excess), gyCenter, ownerIdx)`.
- `main.cpp` (piccola correzione) — evitato il richiamo prematuro a `onDiscardAnimationFinished()` e migliorato il timing di fine-animazione.

Come testare rapidamente
1. Costruire il target Tappa_15 (se necessario):

```powershell
cmake --build <project-root>\build --target mainTappa15 --config Release
```

2. Avviare l'eseguibile `build\bin\mainTappa15.exe`.
3. Forzare uno scarto (ad esempio terminando il turno con più carte della mano del limite) sia per P1 che per P2.
4. Verificare che:
   - la logica del gioco assegni le carte scartate al graveyard del corretto proprietario (`game.getGraveyardOf(0/1)`),
   - l'animazione visiva porti le carte verso il corrispondente slot graveyard sul lato corretto dello schermo.

Note e prossimi passi
- Ho aggiornato solo la Tappa_15; altri Tappa/main.cpp che chiamano ancora `discardController.start(std::move(excess), gyCenter)` senza passare l'owner possono essere aggiornati con lo stesso pattern (`ownerIdx + 1` per la posizione e passare `ownerIdx`).
- Se vuoi, applico lo stesso fix alle altre Tappe (Tappa_11/12/13/14) e ricostruisco i target.

## Modifica degli Effetti carte
- Gli effect handlers delle carte `Pietra bianca della leggenda` e `pietra bianca degli antichi` sono stati adattati per chiamare `mirrorExternalDeckRemoveByName(...)` passando il puntatore al deck sorgente, così da mantenere sincronizzate il numero di carte del deck con gli effetti chiamati Deck UI senza double-remove.

- Correzione effetto `Pietra bianca della leggenda`:
	- Quando l'effetto di "Pietra Bianca della Leggenda" aggiungeva un "Drago Bianco Occhi Blu" dal Deck alla mano, la carta appariva con la texture del retro perché il percorso effetto bypassava il `DrawController` (che normalmente applica la texture frontale). Per risolvere il problema adesso `WhiteStoneLegendEffect` riceve un riferimento a `TextureManager` e chiama `RenderUtils::applyFrontTextureIfAny(...)` prima di aggiungere la carta alla mano. Questo garantisce che la carta inserita dalla logica dell'effetto abbia la texture frontale corretta. Il passaggio di Texture avviene tramite `GameWiring`/`main.cpp` --> ho quindi aggiornato il metodo `registerDefaultEffects()` in `GameWiring`, chiamato da `createGameAndAttachResources`.