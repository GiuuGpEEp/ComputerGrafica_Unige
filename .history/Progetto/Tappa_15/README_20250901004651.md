## Tappa 15 — Changelog delle modifiche funzionali

Dopo aver sistemato un minimo il codice, in questa tappa cerco di fixare tutte le problematiche individuate all'interno del gioco fin'ora, e successivamente di implementare una prima bozza di EffectChain

## Risoluzione Sincronizzazione del deck
Spesso capitava che usando degli effetti che modificano il numero di carte nel deck, quest'ultimi funzionassero anche se la carta scelta non era più presente all'interno del deck stesso.
Ho quindi fatto in modo di sincronizzare correttamente il deck, con tutte le modifiche che gli vengono fatte:

**Modifiche principali**

- `Player` adesso memorizza un puntatore al proprio `Deck` invece di copiarne il contenuto.
  - Scopo: evitare copie accidentali del Deck che causavano differenze tra logica e UI.

- `Game` modifica del metodo per associare il deck al gioco:
  - `attachExternalDeck(Deck*, int)` adesso non prende più come parametro solo il puntatore a deck, ma anche l'indice del player, in modo da non rischiare di avere un unico puntatore per 2 deck.
  - Internamente `Game` conserva `externalDecks[2]` (un array con 2 puntatori a oggetti Deck differenti).
  - `Game::mirrorExternalDeckRemoveByName(const std::string&, const Deck*)` adesso riceve il `sourceDeck` per evitare "double-remove" quando la sorgente della rimozione è già la stessa istanza grafica.
  - Decisione sul deck-out, la condizione di deck-out ora usa lo stato logico del gioco (es. `current().canDraw()`), non lo stato visivo dell'UI.
  - Questo evita vittorie errate dovute a disallineamenti temporanei tra UI e logica.

- `Overlays` (Graveyard / ExtraDeck)
  - Implementata funzione `reset()` che pulisce cache interne, selezioni e bounding boxes.
  - `main.cpp` è stato aggiornato per chiamare i `reset()` appropriati durante `resetMatch` (prima e dopo la ricreazione dei Deck) per evitare residui grafici tra le partite.


- Aggiornamento anche dei file che chiamano i metodi modificati:
  - `GameWiring` ora registra effetti di default, attacca i Deck esterni (`attachExternalDeck`) e collega il `DrawController` al `Game`.
  - `AppHandlers` è stato aggiornato per usare i nuovi hook di sincronizzazione (event handlers: DrawStart/DrawEnd, NormalSummon, CardMoved, ecc.).
  - `main.cpp` aggiorna `resetMatch` per ricreare deck e resettare overlay in modo sicuro.

**File principali modificati**
- `GameLogic/Player/Player.h` — Player ora contiene `Deck*` non-owning.
- `GameLogic/Game/Game.h` / `Game.cpp` — `externalDecks`, `attachExternalDeck`, `mirrorExternalDeckRemoveByName`, deck-out logic.
- `GameLogic/DrawController/DrawController.cpp` — gestione animazioni pesca e `reset()`.
- `GraveyardOverlay/*`, `ExtraDeckOverlay/*` — stato `reset()` per cancellare cache UI.
- `GameWiring/GameWiring.cpp` — inizializzazione effetti, attach deck/draw controller.
- `AppHandlers/AppHandlers.cpp` — wiring degli eventi verso le callback UI.
- `main.cpp` — `resetMatch` aggiornato per ricreare deck, resettare overlay e riallocare le risorse necessarie.

## Modifica Drag ed Evocazioni Tributo

Ho modificato la logica di drag per far si che una volta scelto lo slot la carta torni in mano per poi evocarla, in modo tale che nelle evocazioni tramite tributo la carta non resti in mezzo rendendo difficile la selezione dei tributi:

- Drag/Tribute 
  - Quando si rilascia una carta della mano su campo e parte la procedura di evocazione (Evoca/Posiziona), la carta non rimane più "flottante" al centro: il codice ora richiama un callback `cancelActiveDrag()` che riporta immediatamente la carta nella mano --> callback creata nel main e passata al nostro `Contex`, oppure usata nel main stesso
  - Se la carta viene rilasciata fuori da uno slot valido, la carta torna immediatamente in mano (comportamento già presente: `cardBackToHand`).

- InputController
  - `InputController` ora gestisce `E`/`P`/`A`/`S` come prima, ma con ulteriori protezioni:
    - Se l'utente preme `E` mentre è in drag senza una scelta Evoca/Posiziona attiva, il drag viene annullato e la carta ritorna in mano.

- Highlight per tributi
  - Le carte sul campo che sono state selezionate come tributi ricevono un leggero tint (medesimo effetto visivo usato per la selezione di un attaccante). Questo aiuta l'utente a distinguere i mostri scelti durante la procedura di tributo --> aspetto gestito in `drawMonsterCard` in `RenderUtils` 

## Modifica del discard delle carte nel cimitero - e reset

Breve riassunto delle modifiche fatte per risolvere un problema segnalato dove le carte scartate da P2 finivano nel cimitero di P1 e, successivamente, per allineare le animazioni alla logica:

- Problema risolto: quando un giocatore scartava, le carte venivano talvolta inserite nel `graveyard` del giocatore sbagliato (logica). Ho quindi aggiunto un getter che permette di accedere al graveyard in base al proprietario e modificato anche le animazioni per lo scarto delle carte.
- Animazioni: dopo la correzione della logica, l'animazione risultava invertita (visivamente puntava al lato opposto). La causa era una convenzione diversa tra il `Game` (owner index 0/1) e `Field::getSlotPosition` (player convention 1/2). Ho aggiunto il mapping appropriato quando si calcola la posizione visiva del graveyard.

File toccati (principali)
- `GameLogic/Game/Game.h` / `Game.cpp` — aggiunto `getGraveyardOf(int)` e reso `getGraveyard()` dipendente dal turno corrente.
- `GameLogic/DiscardController/DiscardController.h` / `DiscardController.cpp` — `start(..., int ownerIdx, ...)` ora riceve e memorizza il proprietario; alla fine dell'animazione inserisce le carte nel graveyard del proprietario.
- `GameWiring/GameWiring.cpp` — la callback che avvia l'animazione ora:
  - legge `ownerIdx = game->getTurn().getCurrentPlayerIndex()` (0/1), memorizzando l'indice dell'owner
  - calcola `fieldPlayer = ownerIdx + 1` per `Field::getSlotPosition` --> al posto che passagli 0/1 gli passo 1 o 2 perchè è come avevo salvato i giocatori
  - chiama `discardController.start(std::move(excess), gyCenter, ownerIdx)`.
- `main.cpp` (piccola correzione) — evitato il richiamo prematuro a `onDiscardAnimationFinished()` e migliorato il timing di fine-animazione.

**Altro problema -->** ogni tanto dopo aver finito una partita, se ne iniziavamo un altra poteva capitare che in mezzo al campo fosse presente una carta, che successivamente finiva nel cimitero. Questa probabilmente era un residuo della partita precedente, per risolvere ho fatto questo:
 - Aggiunta all'interno di discardController un `DiscardController::reset()` e implementato per svuotare eventuali animazioni/pending di scarto; ciò evita che sprite/carte residue dalla partita precedente rimangano vicino al cimitero alla creazione di una nuova partita.
 - `GameLogic/DiscardController/DiscardController.h` / `DiscardController.cpp` — aggiunto `reset()`; `main.cpp` ora chiama `discardController.reset()` in `resetMatch` e subito dopo la ricreazione dei deck per evitare residui visivi/animazioni tra partite.


## Modifica degli Effetti carte
- Gli effect handlers delle carte `Pietra bianca della leggenda` e `pietra bianca degli antichi` sono stati adattati per chiamare `mirrorExternalDeckRemoveByName(...)` passando il puntatore al deck sorgente, così da mantenere sincronizzate il numero di carte del deck con gli effetti chiamati Deck UI senza double-remove.

- Correzione effetto `Pietra bianca della leggenda`:
	- Quando l'effetto di "Pietra Bianca della Leggenda" aggiungeva un "Drago Bianco Occhi Blu" dal Deck alla mano, la carta appariva con la texture del retro perché il percorso effetto bypassava il `DrawController` (che normalmente applica la texture frontale). Per risolvere il problema adesso `WhiteStoneLegendEffect` riceve un riferimento a `TextureManager` e chiama `RenderUtils::applyFrontTextureIfAny(...)` prima di aggiungere la carta alla mano. Questo garantisce che la carta inserita dalla logica dell'effetto abbia la texture frontale corretta. Il passaggio di Texture avviene tramite `GameWiring`/`main.cpp` --> ho quindi aggiornato il metodo `registerDefaultEffects()` in `GameWiring`, chiamato da `createGameAndAttachResources`.

 - Comportamento `Pietra bianca degli antichi` (Evocazione Speciale con scelta posizione):
 	- Flusso originale: l'effetto rimuove dal Deck un "Drago Bianco Occhi Blu" e chiama `Game::requestSpecialSummonWithChoice(ownerIdx, card)`. Questo registra una `pendingSS` e emette l'evento `SpecialSummonChoiceRequested`.
  - Modifica introdotta in Game e nell'effetto: l'effetto ora registra il trigger in modo robusto rispetto a chi sia il giocatore di turno. In particolare la Pietra viene considerata "pending" per la End Phase del turno in cui viene mandata al cimitero, indipendentemente da chi sia il giocatore corrente quando l'evento viene emesso. Per farlo il codice determina il proprietario reale controllando quale graveyard ha ricevuto la carta (fallback a `lastSentToGrave.ownerIdx` se necessario) e imposta `pendingThisTurn/ownerIdx` di conseguenza.
    - Ho inoltre aggiunto `Game::getPendingSpecialSummonOwner()` per semplificare l'ottenimento del proprietario della pietra.
    - Questo garantisce che l'effetto si attivi nella End Phase del turno in cui la Pietra è stata mandata al cimitero (es.: se la Pietra viene mandata al cimitero durante l'End Phase dell'avversario, si attiverà in quella stessa End Phase), evocando il BEWD sul terreno del proprietario della Pietra.

  - Aggiornamento della logica `AppHandlers` in risposta all'evento `SpecialSummonChoiceRequested`:
 		- Se il proprietario è il giocatore umano (P1): viene mostrato il prompt per scegliere Attacco o Difesa (`ctx.setSsChoiceActive(true)`).
 		- Se il proprietario è il giocatore AI (P2) l'AI risolve automaticamente la scelta senza aprire il prompt. In questa implementazione l'AI seleziona autonomamente Attacco o Difesa con una scelta casuale ( aggiunta della libreria random e della variabile _apphandlers_rand in `AppHandlers`).
	Quindi l'effetto chiama la funzione definita in Game, che genererà un evento di tipo SpecialSummonChoiceRequested, e verrà gestito dall'HandleDispatcher	
 	
 - Comportamento `Reliquiario del Drago` (Deck send choice):
    - Scopo: quando il Reliquiario viene attivato, il giocatore sceglie un Drago dal proprio Deck da mandare al Cimitero, e poi il Reliquiario viene mandato nel Cimitero.
    - Comportamento introdotto:
      - Se il proprietario è il giocatore umano (P1): si apre il pannello `DeckSendChoice` e il giocatore sceglie manualmente quale Drago mandare al Cimitero (stesso flusso UI di prima).
      - Se il proprietario è il giocatore AI (P2): il pannello non viene mostrato; l'AI seleziona autonomamente una carta Drago dal suo Deck e la manda al Cimitero senza intervento UI.
    - Dettagli tecnici:
      - Aggiunto `Game::getPendingSendOwner()` per conoscere il proprietario della richiesta `requestSendFromDeck`.
      - In `AppHandlers`, il listener per `GameEventType::DeckSendChoiceRequested` ora:
        - se owner==1 (AI) raccoglie i candidati (carte Drago) e risolve automaticamente scegliendo un indice (implementazione corrente: scelta casuale tramite `_apphandlers_rand`) chiamando `resolvePendingSendFromDeck(index)`;
        - se owner==0 (umano) apre il pannello e passa i candidati a `ctx.setDeckSendCandidates` come prima.
      - Dopo che la carta Drago è mandata al Cimitero con `resolvePendingSendFromDeck`, Reliquiario stesso viene spostato dalla Spell/Trap Zone al Cimitero 
    Quindi quando viene attivata la magia l'effetto della carta (gestito nella cartella effects) richiama la funzione requestSendFromDeck in game, che scatenerà un evento di tipo DeckSendChoiceRequested e il seguito verrà gestito da AppHandlers

**Miglioramento precisione della pietra**

- WhiteStoneAncients: migliorata la determinazione del proprietario quando la `Pietra Bianca degli Antichi` viene mandata al cimitero.
  - Ora il codice preferisce il valore registrato in `Game::lastSentToGrave.ownerIdx` (più affidabile) e lo valida controllando che il cimitero del proprietario contenga effettivamente la carta; solo se la validazione fallisce si esegue una scansione difensiva per nome in entrambi i cimiteri.
  - Questo risolve il bug in cui la Pietra veniva attribuita al giocatore che l'aveva distrutta (attack/destroy) anziché al suo controllore.

- Game: aggiunti log di debug brevi ogni volta che `lastSentToGrave` viene impostato (per tracciare quale codice ha registrato l'ultima carta mandata al cimitero). I log stampano il sito chiamante e l'ownerIdx.

- WhiteStoneAncientsEffect: aggiunti log che mostrano quale deck viene ispezionato prima di cercare il "Drago Bianco Occhi Blu" e i primi 8 nomi di carte per ispezionare lo stato del Deck durante il debug.

Nota: i log sono utili per debug e sviluppo; considerare la loro rimozione o la sostituzione con un sistema di logging condizionale prima del rilascio.

