## Tappa 15 — Changelog delle modifiche funzionali

Dopo aver sistemato un minimo il codice, in questa tappa cerco di fixare tutte le problematiche individuate all'interno del gioco fin'ora, e successivamente di implementare una prima bozza di EffectChain

Risoluzione Sincronizzazione del deck**
Spesso capitava che usando degli effetti che modificano il numero di carte nel deck, quest'ultimi funzionassero anche se la carta scelta non era più presente all'interno del deck stesso.
Ho quindi fatto in modo di sincronizzare correttamente il deck, con tutte le modifiche che gli vengono fatte:

**Modifiche principali**

- `Player` adesso memorizza un puntatore al proprio `Deck` invece di copiarne il contenuto.
  - Scopo: evitare copie accidentali del Deck che causavano differenze tra logica e UI.

- `Game` modifica del metodo per associare il deck al gioco:
  - `attachExternalDeck(Deck*, int)` adesso non prende più come parametro solo il puntatore a deck, ma anche l'indice del player, in modo da non rischiare di avere un unico puntatore per 2 deck.
  - Internamente `Game` conserva `externalDecks[2]` (un array con 2 puntatori a oggetti Deck differenti).
  - `Game::mirrorExternalDeckRemoveByName(const std::string&, const Deck*)` adesso riceve il `sourceDeck` per evitare "double-remove" quando la sorgente della rimozione è già la stessa istanza grafica.
  - Decisione sul deck-out, la condizione di deck-out ora usa lo stato logico del gioco (es. `current().canDraw()`), non lo stato visivo dell'UI.
  - Questo evita vittorie errate dovute a disallineamenti temporanei tra UI e logica.

- `Overlays` (Graveyard / ExtraDeck)
  - Implementata funzione `reset()` che pulisce cache interne, selezioni e bounding boxes.
  - `main.cpp` è stato aggiornato per chiamare i `reset()` appropriati durante `resetMatch` (prima e dopo la ricreazione dei Deck) per evitare residui grafici tra le partite.

- Aggiornamento anche dei file che chiamano i metodi modificati:
  - `GameWiring` ora registra effetti di default, attacca i Deck esterni (`attachExternalDeck`) e collega il `DrawController` al `Game`.
  - `AppHandlers` è stato aggiornato per usare i nuovi hook di sincronizzazione (event handlers: DrawStart/DrawEnd, NormalSummon, CardMoved, ecc.).
  - `main.cpp` aggiorna `resetMatch` per ricreare deck e resettare overlay in modo sicuro.

### File principali modificati
- `GameLogic/Player/Player.h` — Player ora contiene `Deck*` non-owning.
- `GameLogic/Game/Game.h` / `Game.cpp` — `externalDecks`, `attachExternalDeck`, `mirrorExternalDeckRemoveByName`, deck-out logic.
- `GameLogic/DrawController/DrawController.cpp` — gestione animazioni pesca e `reset()`.
- `GraveyardOverlay/*`, `ExtraDeckOverlay/*` — stato `reset()` per cancellare cache UI.
- `GameWiring/GameWiring.cpp` — inizializzazione effetti, attach deck/draw controller.
- `AppHandlers/AppHandlers.cpp` — wiring degli eventi verso le callback UI.
- `main.cpp` — `resetMatch` aggiornato per ricreare deck, resettare overlay e riallocare le risorse necessarie.

**

Questa serie di commit ha introdotto alcuni fix UX e integrazioni importanti testate su `Tappa_15`:

- Drag/Tribute UX
  - Quando si rilascia una carta della mano su campo e parte la procedura di evocazione (Evoca/Posiziona), la carta non rimane più "flottante" al centro: il codice ora richiama un callback `cancelActiveDrag()` che riporta immediatamente la carta nella mano.
  - Se la carta viene rilasciata fuori da uno slot valido, la carta torna immediatamente in mano (comportamento già presente: `cardBackToHand`).
  - Se è in corso la raccolta dei tributi (`selectingTributes`), premendo Invio (`Enter`) la selezione viene ora confermata: il controller chiama `Game::completePendingNormalSummon(selectedTributes)` e, se valida, la summon si completa e la UI si riallinea.

- InputController
  - `InputController` ora gestisce `E`/`P`/`A`/`S` come prima, ma con ulteriori protezioni:
    - Se l'utente preme `E` mentre è in drag senza una scelta Evoca/Posiziona attiva, il drag viene annullato e la carta ritorna in mano.
    - `Enter` conferma la selezione dei tributi quando il gioco è nello stato di raccolta tributi.

- Highlight per tributi
  - Le carte sul campo che sono state selezionate come tributi ricevono un leggero tint (medesimo effetto visivo usato per la selezione di un attaccante). Questo aiuta l'utente a distinguere i mostri scelti durante la procedura di tributo.

- Correzione texture per effetti che aggiungono carte in mano
  - L'effetto `WhiteStoneLegendEffect` ora riceve un riferimento a `TextureManager` e chiama `RenderUtils::applyFrontTextureIfAny(...)` prima di aggiungere una carta alla mano, risolvendo il problema della carta aggiunta che mostrava la texture di retro.

## Come testare rapidamente (smoke test)

1. Compila ed esegui il target `mainTappa15` (solo Tappa 15): il top-level CMake può rigenerare più target e fallire se ci sono file mancanti in altri targets; per test veloci è sufficiente buildare solo `mainTappa15`.

2. Passaggi in-game per verificare le correzioni:
   - Seleziona il mazzo Blue-Eyes e avvia la partita.
   - Metti in mano un mostro che richiede tributi (es. un drago di alto livello).
   - Trascina la carta verso il campo e rilasciala su un'area valida: vedrai il messaggio "Premi E per Evocare, P per Posizionare"; la carta tornerà visivamente in mano (non resterà al centro).
   - Se ci sono tributi richiesti, seleziona i mostri da tributare (clic su mostri sul campo) e premi Invio: la summon verrà completata se la selezione è valida.
   - Verifica che i mostri scelti compaiano con un tint leggero mentre sono selezionati.

3. Test effetto `WhiteStoneLegendEffect`:
   - Attiva l'effetto che aggiunge un "Blue-Eyes White Dragon" in mano (es. tramite la Pietra Bianca della Leggenda) e verifica che la carta appaia con la sua texture frontale (non il dorso).

## Note di build
- Per evitare problemi di rigenerazione CMake quando si lavora solo su una tappa, builda localmente il target specifico:

```powershell
cmake --build <path-to-build> --target mainTappa15 --config Release
```

- Se preferisci sistemare a valle la generazione multi-target, posso aggiornare `CMakeLists.txt` per rimuovere o correggere eventuali riferimenti a file mancanti (es. `Tappa_14`), ma lo lascio a tua discrezione.

## Note future e possibili miglioramenti
- Smooth return animation: attualmente la carta ritorna immediatamente in mano; si può migliorare con un'animazione di lerp per un effetto più gradevole.
- Migliorare la UX keyboard-only per la selezione dei tributi (navigazione con frecce e conferma con Enter mostrata in overlay).

---
Aggiornamento del README completato il 30 Agosto 2025 — documenta le modifiche UX e bugfix principali di questa sessione.

**Modifica degli Effetti carte**
- Gli effect handlers delle carte `Pietra bianca della leggenda` e `pietra bianca degli antichi` sono stati adattati per chiamare `mirrorExternalDeckRemoveByName(...)` passando il puntatore al deck sorgente, così da mantenere sincronizzate il numero di carte del deck con gli effetti chiamati Deck UI senza double-remove.

- Correzione effetto `Pietra bianca della leggenda`:
	- Quando l'effetto di "Pietra Bianca della Leggenda" aggiungeva un "Drago Bianco Occhi Blu" dal Deck alla mano, la carta appariva con la texture del retro perché il percorso effetto bypassava il `DrawController` (che normalmente applica la texture frontale). Per risolvere il problema adesso `WhiteStoneLegendEffect` riceve un riferimento a `TextureManager` e chiama `RenderUtils::applyFrontTextureIfAny(...)` prima di aggiungere la carta alla mano. Questo garantisce che la carta inserita dalla logica dell'effetto abbia la texture frontale corretta. Il passaggio di Texture avviene tramite `GameWiring`/`main.cpp` --> ho quindi aggiornato il metodo `registerDefaultEffects()` in `GameWiring`, chiamato da `createGameAndAttachResources`.

