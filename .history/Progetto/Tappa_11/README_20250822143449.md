**Tappa 11 Progetto**:

Nella Tappa precedente abbiamo creato quello che è lo scheletro della logica di gioco, assieme alla funzione per gestire la normal summon. Ora procediamo con lo sviluppo della logica di gioco.

Nella fase precedente, sotto consiglio di Google Gemini, ho aggiunto dei phaseListener che permettono di rilevare quando vi è la terminazione di una fase di gioco, e fare qualcosa di conseguenza. Per esempio all'interno di game aggiungiamo un phaseListener che quando riceve la notifa controlla in che fase ci troviamo, e resetta la normalSummon. Ogni volta che faccio un cambio di fase nel Turn, viene quindi notificato un phaseListener che reagisce di conseguenza.

Gli eventi nel gioco possono tuttavia essere molteplici e non solo eventi che segnalano cambi di fase, ma ho più tipi di evento differenti. Quindi per reagire a più tipi di evento differenti mi servono categorie di listener relativi a differenti tipi di evento. 
Per far ciò non uso quindi i phaseListener dichiarati precedentemente (li rimuovo), ma creao una classe **EventDispatcher** che si occupa di gestire i listener:

- enum class GameEventType --> Ho un valore differente per ogni tipo di evento differente, per il momento ho solo Phase Change, DrawStart, DrawEnd e NormalSummon

- listeners: I listeners non sono altro che una mappa che lega ad un GameEvent un vector di di listener, ovvero un insieme di funzioni. In questo modo per un solo GameEvent ho tutte le possibili funzioni che vanno a gestire quel singolo evento

- subscribe --> Creo un nuovo eventListener prendendo un gameType e una funzione (Handler).
- emit --> è praticamente una notify --> Quando avviene un nuovo evento di un qualsiasi tipo lo si notifica tramite questo metodo. Successivamente all'interno della mappa si cercherà quel relativo evento, e poi si controllano tutte le funzioni associate a quell'evento.

- Un listener è definito da --> un id e un Handler (ovvero una funzione void)

**Aggiornamento di TurnManager** --> rimuovo i phaseListener

**Aggiornamento di Game**: All'interno di game definisco un EventDispatcher. Ogni volta che cambio turno viene fatta l'emit di un evento di tipo PhaseChange. Mentre quando eseguo la normalSummon viene fatta l'emit di un evento di tipo NormalSummon

**Aggiornamento di DrawController**: Definisco un EventDispatcher. Ogni volta che inizio la pescata faccio l'emit di un evento di tipo DrawStart. Mentre quando eseguo l'animazione di pescata termina viene fatta l'emit di un evento di tipo DrawEnd

**Modifica del Main** --> ogni subscription (Listener) ha un id che la rappresenta. Inserisco quindi nel main degli int per la gestione delle subscription

**Aggiunta Logica di Gioco - Modifica di Game**: Quando un player ha più di 7 carte in mano alla fine del turno deve scartare al cimitero alcune tra queste per tornare ad averne 7. Ho quindi aggiunto questa logica.
Per far ciò ho modificato la classe game, aggiungendo il cimitero (e un metodo per farne la get) e un metodo per ottenere il vettore di carte che sono state scartate con lo scopo di disegnarle nel cimitero

**Creazione anche di un DiscardController** Mentre in game prepariamo il vettore di carte scartate poi tramite l'oggetto DiscardController andiamo a spostare effettivamente queste carte all'interno del cimitero. La classe implementa quindi lo spostamento delle carte dal vettore di intermezzo al cimitero e anche un'animazione per lo spostamento di quest'ultime 

Inoltre se si tiene premuto sul cimitero adesso vengono visualizzati gli elementi al suo interno (logica analoga a extraDeckOverlay)

Adatto il main a questa nuova logica creando gli oggetti necessari e usandoli nelle varie fasi.

---

### Nuovi Aggiornamenti 

1. **Auto Draw centralizzato**
	- `Game::attachDrawController()` collega il `DrawController`.
	- `Game::start()` queue automatica delle 5 carte iniziali.
	- Entrando in Draw Phase (`advancePhase()` o `endTurn()`) viene queue-ata automaticamente una pescata se il mazzo non è vuoto.
	- Il `main` invoca solo `drawController.update(...)` (strato di animazione), nessuna decisione logica lì.

2. **Auto Discard (limite mano)**
	- Impostato tramite `game->setHandLimit(HAND_MAXSIZE)` (default 7).
	- Entrando in End Phase `Game` chiama internamente `processEnterEndPhase()` che:
	  * Se la mano supera il limite: estrae le carte eccedenti e richiama la callback registrata con `setDiscardCallback(...)` per avviare l'animazione di scarto.
	  * Se non ci sono eccessi: marca `pendingAutoTurnEnd` (interno) per chiudere il turno automaticamente dopo un frame di End Phase.
	- Al termine dell'animazione di scarto il `main` rileva che non ci sono più animazioni e chiama `game->onDiscardAnimationFinished()` che chiude il turno.

3. **API aggiunte in `Game`**
	- `setHandLimit(size_t)`
	- `setDiscardCallback(std::function<void(std::vector<Card>&&)>)`
	- `fastForwardToEndPhase()` (usata dal tasto T per saltare direttamente alla End Phase applicando le regole intermedie) 
	- `shouldAutoEndTurn()` e `onDiscardAnimationFinished()`
	- `handleEndPhase()` (helper interno riutilizzato)

4. **Gestione tasto T (debug)**
	- Ora: se non sei in End Phase, chiama `fastForwardToEndPhase()`; altrimenti, se End Phase già risolta (nessuno scarto / scarti finiti) termina il turno.
	- La fine turno automatica avviene da sola dopo End Phase se non restano azioni (o dopo animazione scarti).

5. **Eventi attuali**
	- `PhaseChange`, `DrawStart`, `DrawEnd`, `NormalSummon` restano invariati.

6. **Responsabilità attuali**
	- `Game`: stato logico (turni, fasi, normal summon, auto draw, auto discard orchestration, fine turno). 
	- `DrawController`: animazione + aggiunta carta alla mano al termine.
	- `DiscardController`: animazione carta->cimitero, poi inserimento nel graveyard.
	- `main`: input, rendering, chiamate `update()` dei controller, bridging callbacks (senza logica di regole).

Visto che man a mano sto cercando di avvicinarmi alle regole ho aggiunto altri GameEvent all'interno di EventDispatcher:
- TurnStart
- TurnEnd
- StandbySkip

**Perchè?** --> Quando un giocatore pesca passa dalla drawPhase alla standbyPhase in automatico, e se non vi sono effetti attivabili dalla standByPhase si passa direttamente alla MainPhase sempre in automatico. Inserendo questi eventi quindi riesco a far si che quando entro in una nuova drawPhase emetto un evento TurnStart, che verrà poi gestito entrando subito in StandbyPhase, scatenando il nuovo metodo  `processEnterStandby`. Questo metodo controlla che vi siano effetti attivabili. Se non ve ne sono viene fatto l'emit di StandbySkip e si passa subito alla fase successiva.
**Implementazioni fatte nel Game**

**Metodo moveCard**
All'interno della classe Game ho implementato il metodo moveCard. Questo metodo prende in input una zona di source (da dove viene la carta), e una zona di destinazione. Questo metodo permette di rendere molto più efficente lo spostamento di una carta e ne semplifica la logica. Inoltre alla fine dello spostamento fa l'emissione di un evento di tipo CardMoved/CardSentToGrave.
Dopo aver implementato questo metodo ho modificato le implementazioni di normalSummon e discard per far si che nel muovere una carta nel terreno, o nel cimitero si usi la funzione move.

**Implementazioni dei tributi**
Per l'implementazione tramite tributo ho lavorato per gradi: 
Questo tipo di evocazione conta come una normal summon normale, quindi all'interno di tryNormalSummon (classe Game) usiamo il nuovo metodo `requiredTributesFor` che restituisce il numero di tributi necessari per giocare una carta. Se il numero restituito è 0 allora lasciamo tutto così, mentre se è > 0 deleghiamo il compito a un'altra funzione ovvero `beginNormalSummonWithTributes`.
Questa funzione si occupa di verificare se sul campo vi è il numero minimo di tributi per giocare una carta, se vi sono, ed è quindi possibile evocare per tributo viene ritornato true, e mandato un evento RequiredTribute.
Questo serve per avvisare l'utente che servono dei tributi da selezionare per continuare.

Dichiaro quindi un listener che riceve l'evento e chiama la funzione per indicare quanti tributi servono.
L'evocazione resta in pausa finche il flag selectingTributes è true. Una volta che il numero di tributi è stato raggiunto viene chiamato `completePendingNormalSummon`, funzione che prende il vettore con gli indici dei tributi selezionati e chiama a sua volta `tributeMonsters` che si occcupa di mandare i mostri selezionati al cimitero e fare l'emissione di un evento MonstersTributed e CardSentToGraveyard. 
Queste funzioni vengono tutte create all'interno di **Game**.
All'interno del main invece vengono:
- create le variabili per la gestione, ovvero:  
    * Il flag selectingTributes, che viene messo a true quando è necessario selezionare dei mostri, e rimesso a false a selezione finita
    * L'array con gli indici delle carte selezionate
    * tributesNeeded
- Creata la logica di selezione --> Nella parte dove selezionavamo le carte sul campo ho aggiunto la possibilità che, se il flag di selezione è true cerco all'interno degli indici già aggiunti se la carta cliccata (con indice i) è presente. Se non lo è aggiungo. Una volta che ho raggiunto il numero di tributi chiamo la funzione `completePendingNormalSummon` implementata in game
- Creati i vari Listener che alla ricezione degli eventi, gestiscono le funzioni per i tributi:
    * Se ho un evento di tipo NormalSummonTributeRequired, imposto il flag selectingTributes a true
    * Se ho un evento di tipo MonstersTributed o NormalSummon, posiziono le carte sullo schermo con la nuova funzione

Dopo aver implementato il tutto, ho cambiato il modo in cui la carta viene disegnata. Prima la carta veniva spostata in field centrata e tot subito dopo la logica di normal summon. Invece ora ho creato una funzione che effettua gli spostamenti dopo aver fatto tutta la parte di logica, in questo modo sono sicuro che logica e rendering siano sincronizzati

**Gestione Battle Phase**
Dopo aver evocato i mostri il giocatore può scegliere se attaccare o meno passando alla battle phase. Una volta all'interno di quest'ultima il giocatore può scegliere di attaccare o meno, ogni mostro può attaccare una sola volta. 
Se durante l'attacco viene distrutto un mostro in posizione di attacco, il mostro che lo subisce prende anche un danno pari alla differenza di attacco fra i due. Se non sono presenti mostri sul terreno avversario il giocatore può attaccare direttamente i life points dell'avversario.

Per implementare questa logica ho fatto le seguenti modifiche:
- Aggiunti nuovi eventi in **EventDispatcher**: 
	* `AttackDeclared`
	* `AttackResolved`
	* `MonsterDestroyed`
	* `LifePointsChanged`
	* `DirectAttack`
	
- Modifica in **Player** per la gestione dei lifePoints del giocatore:
	* Aggiunto il metodo `setLifePoints`, che setta un valore assoluti di lifePoints
	* Aggiunto il metodo `damege`, che sottrae il quantitativo di danno ai lifePoints 	

- Modifica in **Game**, qui implementiamo la logica effettiva della BattlePhase
	* Aggiunti 2 vector `monsterHasAttacked` (uno per giocatore), al loro interno viene associato ad ogni indice un indice del vettore monsterZone (contenente un mostro); Quindi ogni indice rappresenta un mostro sul terreno, e in quella posizione vi è un booleano che segna se il mostro ha attaccato o meno. L'aggiunta di questi vector mi obbliga a modificare leggermente alcune funzioni. Nel costruttore vado a inizializzare i 2 vettori, nella funzione `startTurn()` vado ogni volta a mettere il vettore del player attivo interamente a false. Nella funzione `move`, quando sposto un mostro all'interno del terreno (vettore monsterZone) aggiungo anche un flag false all'interno di `monsterHasAttacked`. Infine, quando offro come tributo dei mostri, mandandoli al cimitero rimuovo anche i flag corrispondenti agli indici
	* Aggiunta del metodo `canDeclareAttack`: Questo metodo prende in input l'indice dell'attaccante, e l'indice del target dell'attacco, e ritorna true se è effettivamente possibile fare l'attacco. Valuta quindi se l'indice dell'attaccante è un  indice valido, valuta se quel mostro ha già attaccato tramite `monsterHasAttacked`, e se l'indice del target ha un valore ritorna true se quel valore è valido. Se invece non ha valore ritorna true se le zone mostri avversario sono vuote.
	* Aggiunta del metodo `declareAttack`: Questo metodo prende in input 2 indici, e chiama `canDeclareAttack`, se viene ritornato true allora si continua prendendo l'indice del current e dell'opponent, viene poi emesso un evento attack declared. Se gli indici sono validi poi basandomi su quest'ultimi prendo il valore di attacco della carta che attacca, e di quella che difende, e in base a chi ha l'attacco maggiore vediamo quale dei due viene distrutto e chi subisce il danno. Se non ho un indice come target, allora avviene un attacco diretto e viene emesso l'evento DirectAttack. Dopo la terminazione dell'attacco (che sia diretto o meno) viene successivamente emesso un evento AttackResolved
	* Aggiunta anche dei metodi helper `dealDamageTo`, che chiama damage e infligge danno (emissione evento LifePointsChanged), e `destroyMonster` che si occupa di spostare il mostro dal terreno al cimitero e fare un'emit dell'evento CardSentToGrave e MonsterDestroyed.       	

---

### Controlli UI Battle Phase (v1)

- Passa di fase con N fino a Battle.
- Clic su un tuo mostro sul campo per selezionarlo (tinta giallo chiaro per evidenziare).
- Premi A per effettuare un Attacco Diretto se il campo avversario è vuoto.
- Ogni mostro può attaccare una volta per turno; i Life Points sono mostrati in alto a destra (Current | Opp).

Note: in questa versione non è ancora possibile selezionare un bersaglio avversario perché non viene renderizzata la zona mostri dell'opponente. Gli eventi di combattimento aggiornano comunque correttamente cimitero e LP.

