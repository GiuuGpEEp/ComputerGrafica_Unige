**Tappa 11 Progetto**:

Nella Tappa precedente abbiamo creato quello che è lo scheletro della logica di gioco, assieme alla funzione per gestire la normal summon. Ora procediamo con lo sviluppo della logica di gioco.

Nella fase precedente, sotto consiglio di Google Gemini, ho aggiunto dei phaseListener che permettono di rilevare quando vi è la terminazione di una fase di gioco, e fare qualcosa di conseguenza. Per esempio all'interno di game aggiungiamo un phaseListener che quando riceve la notifa controlla in che fase ci troviamo, e resetta la normalSummon. Ogni volta che faccio un cambio di fase nel Turn, viene quindi notificato un phaseListener che reagisce di conseguenza.

Gli eventi nel gioco possono tuttavia essere molteplici e non solo eventi che segnalano cambi di fase, ma ho più tipi di evento differenti. Quindi per reagire a più tipi di evento differenti mi servono categorie di listener relativi a differenti tipi di evento. 
Per far ciò non uso quindi i phaseListener dichiarati precedentemente (li rimuovo), ma creao una classe **EventDispatcher** che si occupa di gestire i listener:

- enum class GameEventType --> Ho un valore differente per ogni tipo di evento differente, per il momento ho solo Phase Change, DrawStart, DrawEnd e NormalSummon

- listeners: I listeners non sono altro che una mappa che lega ad un GameEvent un vector di di listener, ovvero un insieme di funzioni. In questo modo per un solo GameEvent ho tutte le possibili funzioni che vanno a gestire quel singolo evento

- subscribe --> Creo un nuovo eventListener prendendo un gameType e una funzione (Handler).
- emit --> è praticamente una notify --> Quando avviene un nuovo evento di un qualsiasi tipo lo si notifica tramite questo metodo. Successivamente all'interno della mappa si cercherà quel relativo evento, e poi si controllano tutte le funzioni associate a quell'evento.

- Un listener è definito da --> un id e un Handler (ovvero una funzione void)

**Aggiornamento di TurnManager** --> rimuovo i phaseListener

**Aggiornamento di Game**: All'interno di game definisco un EventDispatcher. Ogni volta che cambio turno viene fatta l'emit di un evento di tipo PhaseChange. Mentre quando eseguo la normalSummon viene fatta l'emit di un evento di tipo NormalSummon

**Aggiornamento di DrawController**: Definisco un EventDispatcher. Ogni volta che inizio la pescata faccio l'emit di un evento di tipo DrawStart. Mentre quando eseguo l'animazione di pescata termina viene fatta l'emit di un evento di tipo DrawEnd

**Modifica del Main** --> ogni subscription (Listener) ha un id che la rappresenta. Inserisco quindi nel main degli int per la gestione delle subscription

**Aggiunta Logica di Gioco - Modifica di Game**: Quando un player ha più di 7 carte in mano alla fine del turno deve scartare al cimitero alcune tra queste per tornare ad averne 7. Ho quindi aggiunto questa logica.
Per far ciò ho modificato la classe game, aggiungendo il cimitero (e un metodo per farne la get) e un metodo per ottenere il vettore di carte che sono state scartate con lo scopo di disegnarle nel cimitero

**Creazione anche di un DiscardController** Mentre in game prepariamo il vettore di carte scartate poi tramite l'oggetto DiscardController andiamo a spostare effettivamente queste carte all'interno del cimitero. La classe implementa quindi lo spostamento delle carte dal vettore di intermezzo al cimitero e anche un'animazione per lo spostamento di quest'ultime 

Inoltre se si tiene premuto sul cimitero adesso vengono visualizzati gli elementi al suo interno (logica analoga a extraDeckOverlay)

