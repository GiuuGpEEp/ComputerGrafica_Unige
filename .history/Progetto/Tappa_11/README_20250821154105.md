**Tappa 11 Progetto**:

Nella Tappa precedente abbiamo creato quello che è lo scheletro della logica di gioco, assieme alla funzione per gestire la normal summon. Ora procediamo con lo sviluppo della logica di gioco.

Nella fase precedente, sotto consiglio di Google Gemini, ho aggiunto dei phaseListener che permettono di rilevare quando vi è la terminazione di una fase di gioco, e fare qualcosa di conseguenza. Per esempio all'interno di game aggiungiamo un phaseListener che quando riceve la notifa controlla in che fase ci troviamo, e resetta la normalSummon. Ogni volta che faccio un cambio di fase nel Turn, viene quindi notificato un phaseListener che reagisce di conseguenza.

Gli eventi nel gioco possono tuttavia essere molteplici e non solo eventi che segnalano cambi di fase, ma ho più tipi di evento differenti. Quindi per reagire a più tipi di evento differenti mi servono categorie di listener relativi a differenti tipi di evento. 
Per far ciò non uso quindi i phaseListener dichiarati precedentemente (li rimuovo), ma creao una classe **EventDispatcher** che si occupa di gestire i listener:

- enum class GameEventType --> Ho un valore differente per ogni tipo di evento differente, per il momento ho solo Phase Change, DrawStart, DrawEnd e NormalSummon

- listeners: I listeners non sono altro che una mappa che lega ad un GameEvent un vector di di listener, ovvero un insieme di funzioni. In questo modo per un solo GameEvent ho tutte le possibili funzioni che vanno a gestire quel singolo evento

- subscribe --> Creo un nuovo eventListener prendendo un gameType e una funzione (Handler).
- emit --> è praticamente una notify --> Quando avviene un nuovo evento di un qualsiasi tipo lo si notifica tramite questo metodo. Successivamente all'interno della mappa si cercherà quel relativo evento, e poi si controllano tutte le funzioni associate a quell'evento.

- Un listener è definito da --> un id e un Handler (ovvero una funzione void)

**Aggiornamento di TurnManager** --> rimuovo i phaseListener

**Aggiornamento di Game**: All'interno di game definisco un EventDispatcher. Ogni volta che cambio turno viene fatta l'emit di un evento di tipo PhaseChange. Mentre quando eseguo la normalSummon viene fatta l'emit di un evento di tipo NormalSummon

**Aggiornamento di DrawController**: Definisco un EventDispatcher. Ogni volta che inizio la pescata faccio l'emit di un evento di tipo DrawStart. Mentre quando eseguo l'animazione di pescata termina viene fatta l'emit di un evento di tipo DrawEnd

**Modifica del Main** --> ogni subscription (Listener) ha un id che la rappresenta. Inserisco quindi nel main degli int per la gestione delle subscription

**Aggiunta Logica di Gioco - Modifica di Game**: Quando un player ha più di 7 carte in mano alla fine del turno deve scartare al cimitero alcune tra queste per tornare ad averne 7. Ho quindi aggiunto questa logica.
Per far ciò ho modificato la classe game, aggiungendo il cimitero (e un metodo per farne la get) e un metodo per ottenere il vettore di carte che sono state scartate con lo scopo di disegnarle nel cimitero

**Creazione anche di un DiscardController** Mentre in game prepariamo il vettore di carte scartate poi tramite l'oggetto DiscardController andiamo a spostare effettivamente queste carte all'interno del cimitero. La classe implementa quindi lo spostamento delle carte dal vettore di intermezzo al cimitero e anche un'animazione per lo spostamento di quest'ultime 

Inoltre se si tiene premuto sul cimitero adesso vengono visualizzati gli elementi al suo interno (logica analoga a extraDeckOverlay)

Adatto il main a questa nuova logica creando gli oggetti necessari e usandoli nelle varie fasi.

---

### Aggiornamenti recenti (centralizzazione punti 2 e 3 del piano)

1. **Auto Draw centralizzato**
	- `Game::attachDrawController()` collega il `DrawController`.
	- `Game::start()` queue automatica delle 5 carte iniziali.
	- Entrando in Draw Phase (`advancePhase()` o `endTurn()`) viene queue-ata automaticamente una pescata se il mazzo non è vuoto.
	- Il `main` invoca solo `drawController.update(...)` (strato di animazione), nessuna decisione logica lì.

2. **Auto Discard (limite mano)**
	- Impostato tramite `game->setHandLimit(HAND_MAXSIZE)` (default 7).
	- Entrando in End Phase `Game` chiama internamente `processEnterEndPhase()` che:
	  * Se la mano supera il limite: estrae le carte eccedenti e richiama la callback registrata con `setDiscardCallback(...)` per avviare l'animazione di scarto.
	  * Se non ci sono eccessi: marca `pendingAutoTurnEnd` (interno) per chiudere il turno automaticamente dopo un frame di End Phase.
	- Al termine dell'animazione di scarto il `main` rileva che non ci sono più animazioni e chiama `game->onDiscardAnimationFinished()` che chiude il turno.

3. **API aggiunte in `Game`**
	- `setHandLimit(size_t)`
	- `setDiscardCallback(std::function<void(std::vector<Card>&&)>)`
	- `fastForwardToEndPhase()` (usata dal tasto T per saltare direttamente alla End Phase applicando le regole intermedie) 
	- `shouldAutoEndTurn()` e `onDiscardAnimationFinished()`
	- `handleEndPhase()` (helper interno riutilizzato)

4. **Gestione tasto T (debug)**
	- Ora: se non sei in End Phase, chiama `fastForwardToEndPhase()`; altrimenti, se End Phase già risolta (nessuno scarto / scarti finiti) termina il turno.
	- La fine turno automatica avviene da sola dopo End Phase se non restano azioni (o dopo animazione scarti).

5. **Eventi attuali**
	- `PhaseChange`, `DrawStart`, `DrawEnd`, `NormalSummon` restano invariati.
	- Lo scarto non emette ancora un evento dedicato (si può introdurre in futuro: `DiscardStart` / `DiscardEnd`).

6. **Responsabilità attuali**
	- `Game`: stato logico (turni, fasi, normal summon, auto draw, auto discard orchestration, fine turno). 
	- `DrawController`: animazione + aggiunta carta alla mano al termine.
	- `DiscardController`: animazione carta->cimitero, poi inserimento nel graveyard.
	- `main`: input, rendering, chiamate `update()` dei controller, bridging callbacks (senza logica di regole).

Visto che man a mano sto cercando di avvicinarmi alle regole ho aggiunto altri GameEvent all'interno di EventDispatcher:
- TurnStart
- TurnEnd
- StandbySkip

**Perchè?** --> Quando un giocatore pesca passa dalla drawPhase alla standbyPhase in automatico, e se non vi sono effetti attivabili dalla standByPhase si passa direttamente alla MainPhase sempre in automatico. Inserendo questi eventi quindi riesco a far si che quando entro in una nuova drawPhase emetto un evento TurnStart, che verrà poi gestito entrando subito in StandbyPhase, scatenando il nuovo metodo  `processEnterStandby`. Questo metodo controlla che vi siano effetti attivabili. Se non ve ne sono viene fatto l'emit di StandbySkip e si passa subito alla fase successiva.
   