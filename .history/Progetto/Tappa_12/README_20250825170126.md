**Tappa 12 Progetto**

**Aggiunta Del Blocco Win-Lose**
Adesso Gestisco la casistica di vittoria o sconfitta. Un giocatore vince quando, o riesce ad azzerare i lifePoints dell'avversario, oppure l'avversario va in deck-out --> cerca di pescare avendo finito le carte nel deck.

Per implementare questa logica ho modificato la classe **Game** aggiungendo:
- Flag `gameOver` e relativo metodo getter
- indice `winnerIndex` per indicare il vincitore e relativo metodo getter
- Metodo `checkVictoryByLP` usato all'interno del metodo `dealDamage`, che controlla i lifePoints e se si è raggiunto 0 viene sollevato un evento Win e un evento Lose
- metodo `handleDeckOutIfAny` che controlla le carte nel deck prima di ogni pescata, e in caso solleva un evento Win e un evento Lose

**Gestione GUI nel main**
Nel main gestisco la GUI:
- Aggiunta di un booleano `gameOverActive`, se messo a True vengono gestiti unicamente gli eventi di pressione del tasto space per tornare alla Home
- Se il gameOver è active le animazioni sono in pausa --> `deltaTime` = 0
- Ho aggiunto i subscribers che gestiscono gli eventi di Win e Lose, in modo che quando viene rilevato uno dei due viene messo a true gameOver
- Aggiunto il rendering effettivo all'interno del main (da spostare successivamente)

Ho fatto successivamente alcune modifiche alla GUI aggiungendo un pallino rosso per simboleggiare i mostri che hanno già attaccato. Inoltre ho modificato Game aggiungendo lo spostamento per le carte bandite, e sistemando il cimitero -> prima vi era un solo cimitero ora ve ne sono due, come anche le monsterZone

**Posizionamento dei mostri (Set) integrato con i Tributi**
Nel gioco ufficiale, durante la Normal Summon si può:
- Evocare in Attacco scoperto; oppure
- Posizionare (Set): carta coperta in posizione di Difesa; conta come Normal Summon del turno.

Modifiche in `Game`:
- Nuovo evento `NormalSet`.
- Stato per posizione per ciascun mostro: `monsterIsDefense`, `monsterIsFaceDown` (allineati a `monsterZones`).
- Nuove API:
	- `bool tryNormalSet(size_t handIndex)` – come `tryNormalSummon`, ma posiziona DEF coperto; richiede gli stessi tributi dei mostri alti.
	- `bool setPosition(size_t zoneIndex, bool defense, bool faceDown=false)`.
	- `bool isDefenseAt(int playerIdx, size_t zoneIndex) const`, `bool isFaceDownAt(...) const`.
- Tributi: overload `beginNormalSummonWithTributes(size_t handIndex, bool asSet)` memorizza l’intento; `completePendingNormalSummon` evoca o setta in base a tale flag e emette `NormalSummon` o `NormalSet`.
- Coerenza vettori: allineamento di flag posizione e attacco su `moveCard`, `destroyMonster`, `tributeMonsters`.
- Attacchi: `canDeclareAttack` ora blocca se il mostro è in Difesa o coperto.

GUI (main):
- Quando si droppa una carta su uno slot valido, appare una scelta rapida: premi `E` per Evocazione, `P` per Posizionamento. Se servono tributi parte il flusso di selezione e, a fine tributi, la carta viene evocata o settata in base alla scelta.
- Subscribe a `NormalSet` (oltre a `NormalSummon` e `MonstersTributed`) per sincronizzare il render del campo.

**Regole e API per Posizionamento e Cambio Posizione (Game)**
- Stato per ogni mostro su campo: `monsterIsDefense`, `monsterIsFaceDown`, `monsterHasAttacked`, `monsterSummonedThisTurn`, `monsterPositionChangedThisTurn`.
- Reset a inizio turno (funzione start turn del giocatore corrente): azzera `monsterPositionChangedThisTurn` e pulisce `monsterSummonedThisTurn`.
- modifica della `moveCard` --> ho aggiunto il flag per capire se lo spostamento parte dalla zona mostri --> se è così devo riallineare tutti i vector associati alla monsterZone. Mentre se lo spostamento arriva in monsterZone aggiungo elementi nei vettori 
- La stessa coerenza dei flag modificata e mantenuta in moveCard viene mantunata anche in: `destroyMonster`, `tributeMonsters`,`debugAddMonsterToOpponent` e `completePendingNormalSummon`
- API principali:
  - `bool tryNormalSet(size_t handIndex)` – setta in Difesa coperta (gestisce tributi come Normal Summon).
  - `bool setPosition(size_t zoneIndex, bool defense, bool faceDown=false, bool allowByEffect=false)` – cambia posizione rispettando le regole.
  - `bool togglePosition(size_t zoneIndex, bool allowByEffect=false)` – applica automaticamente la transizione ammessa.
  - Query: `isDefenseAt(...)`, `isFaceDownAt(...)`.
- Regole di cambio posizione applicate in `setPosition`/`togglePosition`:
  1) Direzionali:
	  - Se la carta è coperta: può solo passare a Attacco scoperto.
	  - Se è in Attacco: può solo passare a Difesa scoperta.
	  - Se è in Difesa: può solo passare a Attacco scoperto.
  2) Turno/evocazione:
	  - Se la carta è stata evocata/settata in questo turno: non può cambiare posizione.
	  - Ogni mostro può cambiare posizione al massimo una volta per turno.
  3) Fasi:
	  - Consentito solo in Main Phase 1 o Main Phase 2, salvo `allowByEffect=true` (per effetti di carte).

**Aggiunto in classe Card il metodo per ruotare effettivamente una carta**

**Rendering carta coperta, Difesa implementata nel main**
- Carte settate: disegnate sempre con il retro (`textureFlipped`) sia per P1 che per P2.
- Carte in Difesa e/o coperte: rese orizzontali (rotazione 90°) con proporzioni più schiacciate e centratura nello slot; lieve tinta per distinguerle.
- Mappatura campo stabile: il campo del Player 0 è sempre in basso (P1), Player 1 sempre in alto (P2), indipendentemente dal turno; sincronizzato su `TurnStart`/`TurnEnd` e `CardMoved`.
- Attacchi: puntino rosso su mostri che hanno già attaccato; `canDeclareAttack` blocca attacchi da Difesa o coperti.

**Combattimento v2: flip in battaglia e regole danni corrette**
Ho modificato il metodo declareAttack della classe Game in modo tale che:
- Se attacchi un mostro coperto, esso viene scoperto prima del calcolo danni: vengono emessi `CardMoved` (per il render) e `MonsterFlipped` (per gli effetti).
- ATK vs ATK: chi ha ATK minore viene distrutto; se uguali, entrambi distrutti; il perdente subisce danni pari alla differenza.
- ATK vs DEF: nessun “piercing” per ora.
	- Se ATK > DEF: il difensore viene distrutto, nessun danno al suo controllore.
	- Se ATK < DEF: l’attaccante NON viene distrutto; il suo controllore subisce danni pari a (DEF − ATK).
	- Se ATK == DEF: nessuna distruzione, nessun danno.
- L’attaccante viene marcato come “ha attaccato” a fine risoluzione (anche in caso di difesa).

Eventi aggiunti:
- `MonsterFlipped`: emesso quando un mostro viene scoperto (flip) sul campo; inoltrato anche all’`EffectSystem`.

**Interazioni UI (main)**
- Drop su slot valido: scelta rapida `E` (Evoca in Attacco) / `P` (Posiziona in Difesa coperta). `ESC` annulla e la carta torna in mano.
- Cambio posizione: un solo tasto `C` per togglare secondo le regole direzionali; soggetto ai vincoli di turno e fase descritti sopra.
- Altri dettagli:
  - L'hover-lift della mano è disabilitato durante la scelta Evoca/Posiziona.
  - Eventi sottoscritti per aggiornare la UI: `NormalSummonTributeRequired`, `MonstersTributed`, `NormalSummon`, `NormalSet`, `TurnStart`, `TurnEnd`, `AttackDeclared/Resolved`, `CardMoved`, `LifePointsChanged`, `DirectAttack`, `Win/Lose`.

**Bozze Per gli Effetti**
All'interno del gioco vi sono alcuni mostri che posseggono degli effetti, così come le carte magia e trappola, anche loro posseggono gli effetti. 
Per far ciò (per il momento) ho aggiunto l'interfaccia minimale --> `ICardEffect.h`

Un oggetto che implementa quest'interfaccia ha a disposizione un metodo `onEvent()`.
All'interno di game ho inserito un nuovo metodo `dispatchEffects`, che solleva eventi di un determinato tipo tra quelli già presenti (TurnStart, TurnEnd, ...).
L'idea è che quando dispatchEffects emette un determinato evento, un oggetto che implementa ICardEffect reagisce a quell'evento tramite il metodo `onEvent`.

Ho poi creato una classe dedicata `EffectSystem` che si occupa di fare `dispatchEffects` (Game delega a EffectSystem) e di registrare gli effetti --> creo una map che associa al nome di una carta il suo effetto. 

L'idea è quindi che:
- Game emette eventi (enum GameEventType) nei punti chiave; in parallelo chiama effects.dispatch(evento, game).
- EffectSystem: scansiona il campo, trova le carte i cui nomi hanno un ICardEffect registrato e invoca onEvent(evento, game) su quell’effetto.

Nella classe Game ho aggiunto quindi una modifica nel costruttore della classe stessa --> quando si verifica un qualsiasi tipo di evento vi è una nuova subscription che gestisce quel tipo di evento, chiamando la `dispatchEvents`.
In questo modo ogni volta che si verifica un evento di quel genere viene chiamato `dispatch` all'interno di EffectSystem

**Classe EffectSystem**
- Contiene la map `registry` per associare il nome di una carta al suo effetto
- Contiene un booleano `dispatching` per evitare un ricontrollo
- Contiene un metodo `registerEffectForCardName` per registrare una carta all'interno della mappa
- Contiene il metodo `dispatch` -> quando viene rilevato un evento il booleano `dispatching` viene messo a true e attivo gli effetti dei vari mostri presenti sul terreno

**Effetti implementati (carte specifiche)**
- Pietra Bianca della Leggenda ("Pietra Bianca della Leggenda"):
	- Trigger: quando viene mandata al Cimitero (`CardSentToGrave`).
	- Effetto: cerca nel Deck "Drago Bianco Occhi Blu" e lo aggiunge alla mano del proprietario.
	- Supporto in `Game`/`Deck`:
		- `Game::addToHand(int playerIdx, Card&&)` per aggiungere direttamente una carta alla mano.
		- `Deck::removeFirstByName(const std::string&)` per rimuovere la prima occorrenza per nome.
		- `Game::lastSentToGrave` (hook interno) per conoscere la carta e il proprietario coinvolti nell'evento.

- Pietra Bianca degli Antichi ("Pietra Bianca degli Antichi"):
	- Trigger: durante l'End Phase del turno in cui è stata mandata al Cimitero.
	- Effetto: Evoca Specialmente dal Deck un "Drago Bianco Occhi Blu" chiedendo al giocatore la posizione (Attacco scoperto o Difesa scoperta). Non è mai coperta.
	- Flusso: l'effetto invoca `Game::requestSpecialSummonWithChoice(ownerIdx, std::move(card))` → viene emesso un evento per la UI che mostra l'overlay di scelta → la UI chiama `Game::resolvePendingSpecialSummon(bool defense)` con la scelta.
	- Vincoli: il turno non può avanzare finché la scelta non viene risolta; se la Monster Zone è piena, l'evocazione fallisce e la scelta viene annullata.

**Nuovi Eventi (EventDispatcher)**
- `SpecialSummonChoiceRequested`: emesso quando un effetto richiede di scegliere la posizione per un'Evocazione Speciale. La UI deve mettersi in stato di scelta e bloccare input confliggenti finché la scelta non viene risolta.

**Nuove API in Game**
- `bool requestSpecialSummonWithChoice(int playerIdx, Card&& c)`
	- Registra una Evocazione Speciale pendente e emette `SpecialSummonChoiceRequested`.
- `bool resolvePendingSpecialSummon(bool defense)`
	- Consuma la scelta e posiziona il mostro in campo scoperto, in Attacco o Difesa secondo il parametro.
- `bool hasPendingSpecialSummon() const`
	- Espone lo stato di una eventuale evocazione speciale in attesa di scelta.
- `bool isFaceDownAt(int playerIdx, size_t zoneIndex) const`
	- Query già usata dalla UI per disegnare il retro se necessario.

Note di timing/turno (End Phase):
- L'End Phase non va in auto-end turn se esiste una Evocazione Speciale pendente: la logica interna (`shouldAutoEndTurn`) ritorna `false` finché la scelta non viene risolta.

**UX: Evocazione Speciale con scelta posizione**
- Alla richiesta di scelta (`SpecialSummonChoiceRequested`) viene mostrato un overlay che chiede:
	- `A` = Evoca in Attacco (scoperto)
	- `D` = Evoca in Difesa (scoperto, ruotata)
- Finché l'overlay è attivo:
	- Sono bloccati avanzamento fase (`N`) e fine turno (`T`).
	- Viene disabilitato l'hover-lift della mano per evitare input ambigui.
	- Alla pressione di `A`/`D` la UI chiama `resolvePendingSpecialSummon(...)` e chiude l'overlay.

**Fix grafici e coerenza texture**
- Evocazioni Speciali da effetti vengono sempre in scoperto: mai coperto.
- Corretto un problema per cui il BEWD evocato appariva con la texture "retro/flipped":
	- Durante la sincronizzazione del campo, se la carta è scoperta, viene forzata la texture frontale originale; se in Difesa viene solo ruotata mantenendo il fronte.

**Note e casi limite**
- Se non c'è spazio nella Monster Zone quando si risolve l'effetto degli Antichi, l'evocazione fallisce (non viene consumata nessuna scelta) e il turno può poi avanzare normalmente.
- La scelta posizione degli Antichi non conta come cambio posizione del turno (è parte dell'evocazione speciale).
