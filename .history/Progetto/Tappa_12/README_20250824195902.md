**Tappa 12 Progetto**

**Aggiunta Del Blocco Win-Lose**
Adesso Gestisco la casistica di vittoria o sconfitta. Un giocatore vince quando, o riesce ad azzerare i lifePoints dell'avversario, oppure l'avversario va in deck-out --> cerca di pescare avendo finito le carte nel deck.

Per implementare questa logica ho modificato la classe **Game** aggiungendo:
- Flag `gameOver` e relativo metodo getter
- indice `winnerIndex` per indicare il vincitore e relativo metodo getter
- Metodo `checkVictoryByLP` usato all'interno del metodo `dealDamage`, che controlla i lifePoints e se si è raggiunto 0 viene sollevato un evento Win e un evento Lose
- metodo `handleDeckOutIfAny` che controlla le carte nel deck prima di ogni pescata, e in caso solleva un evento Win e un evento Lose

**Gestione GUI nel main**
Nel main gestisco la GUI:
- Aggiunta di un booleano `gameOverActive`, se messo a True vengono gestiti unicamente gli eventi di pressione del tasto space per tornare alla Home
- Se il gameOver è active le animazioni sono in pausa --> `deltaTime` = 0
- Ho aggiunto i subscribers che gestiscono gli eventi di Win e Lose, in modo che quando viene rilevato uno dei due viene messo a true gameOver
- Aggiunto il rendering effettivo all'interno del main (da spostare successivamente)

Ho fatto successivamente alcune modifiche alla GUI aggiungendo un pallino rosso per simboleggiare i mostri che hanno già attaccato. Inoltre ho modificato Game aggiungendo lo spostamento per le carte bandite, e sistemando il cimitero -> prima vi era un solo cimitero ora ve ne sono due, come anche le monsterZone

**Posizionamento dei mostri**
Quando viene evocato per evocazione normale un mostro nel gioco ufficiale abbiamo 2 possibilità:
- Mostro evocato --> posizione attacco
- Mostro posizionato --> il mostro viene messo coperto in posizione di difesa --> non può attaccare ne attivare effetti finchè resta coperto

Per implementare questa logica ho aggiunto un altro tipo di evento: fatto alcune modifihe in 



**Bozze Per gli Effetti**
All'interno del gioco vi sono alcuni mostri che posseggono degli effetti, così come le carte magia e trappola, anche loro posseggono gli effetti. 
Per far ciò (per il momento) ho aggiunto l'interfaccia minimale --> `ICardEffect.h`

Un oggetto che implementa quest'interfaccia ha a disposizione un metodo `onEvent()`.
All'interno di game ho inserito un nuovo metodo `dispatchEffects`, che solleva eventi di un determinato tipo tra quelli già presenti (TurnStart, TurnEnd, ...).
L'idea è che quando dispatchEffects emette un determinato evento, un oggetto che implementa ICardEffect reagisce a quell'evento tramite il metodo `onEvent`.

Ho poi creato una classe dedicata `EffectSystem` che si occupa di fare `dispatchEffects` (Game delega a EffectSystem) e di registrare gli effetti --> creo una map che associa al nome di una carta il suo effetto. 

L'idea è quindi che:
- Game emette eventi (enum GameEventType) nei punti chiave; in parallelo chiama effects.dispatch(evento, game).
- EffectSystem: scansiona il campo, trova le carte i cui nomi hanno un ICardEffect registrato e invoca onEvent(evento, game) su quell’effetto.

Nella classe Game ho aggiunto quindi una modifica nel costruttore della classe stessa --> quando si verifica un qualsiasi tipo di evento vi è una nuova subscription che gestisce quel tipo di evento, chiamando la `dispatchEvents`.
In questo modo ogni volta che si verifica un evento di quel genere viene chiamato `dispatch` all'interno di EffectSystem

**Classe EffectSystem**
- Contiene la map `registry` per associare il nome di una carta al suo effetto
- Contiene un booleano `dispatching` per evitare un ricontrollo
- Contiene un metodo `registerEffectForCardName` per registrare una carta all'interno della mappa
- Contiene il metodo `dispatch` -> quando viene rilevato un evento il booleano `dispatching` viene messo a true e attivo gli effetti dei vari mostri presenti sul terreno 

