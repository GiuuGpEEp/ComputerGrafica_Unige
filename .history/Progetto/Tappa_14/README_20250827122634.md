## Tappa 14

Questo step introduce un mini-refactor focalizzato sulla gestione centralizzata delle risorse (texture/font) e sulla pulizia di `main.cpp`.

## Modifiche principali

- Introdotta una configurazione centralizzata in `Config.h` per path risorse e accesso alle texture tramite chiavi simboliche.
- Rimosse dal `main.cpp` tutte le variabili locali per singola texture (es. `textureFlipped`, `homeScreenTexture`, ecc.).
- Tutti i punti che usavano quelle variabili ora accedono alle texture tramite mappa e chiavi (`TextureKey`).
- Uniformato l’utilizzo della texture del retro carta in tutte le sezioni (deck reset, draw, rendering coperto, ecc.).
- Aggiunta una utility robusta per caricare il font con fallback di sistema su Windows.

## Config.h

`Progetto/Tappa_14/Config.h` fornisce:

- Path centralizzati:
	- `resourceBase`, `texturePath`, `fontPath`, `cardsJsonPath`, `decksJsonPath`.
- Enum `TextureKey` con le chiavi per le principali texture dell’app:
	- `FieldBackground`, `MonsterText`, `SpellTrap`, `Deck`, `Graveyard`, `ExtraDeck`, `FieldSpell`, `CardBack`, `CardFrontNotSet`, `StartScreen`, `HomeScreen`, `DeckSelectionScreen`.
- `texturePathMap()` che mappa ogni `TextureKey` al file corrispondente.
- `buildTextureMap(TextureManager&)` che costruisce una mappa `TextureKey -> sf::Texture*` caricando le texture tramite `TextureManager`.
- `findTextureInMap(map, key)` per recuperare velocemente una `sf::Texture&` dalla mappa.
- `loadDetailFont(sf::Font&, const std::string&)` che carica il font principale e, se fallisce, tenta `C:/Windows/Fonts/calibri.ttf`.

Nota: è incluso `SFML/Graphics.hpp` in `Config.h` per tipizzare correttamente le texture e il font.

## main.cpp

`Progetto/Tappa_14/main.cpp` è stato semplificato:

- All’avvio viene costruita una mappa texture con:
	- `auto tex = AppConfig::buildTextureMap(textureManager);`
- Le texture sono reperite on-demand con:
	- `AppConfig::findTextureInMap(tex, AppConfig::TextureKey::<Chiave>)`.
- Aggiornati i punti principali:
	- `ResourceManager::initialize(...)` usa `CardBack` via mappa.
	- Reset posizioni deck: `Deck::resetDeckCardPositions(..., CardBack)`.
	- `HomePage`, `DeckSelectionScreen` e `FieldLoadingAnimation` ricevono le texture tramite `findTextureInMap`.
	- Rendering carte coperte (P1/P2 e mano P2) usa sempre `CardBack` via mappa.
	- Start screen: `drawStartScreen(..., StartScreen, ...)` recuperata via mappa.
- Niente più variabili come `textureFlipped`, `homeScreenTexture`, `fieldTexture`, `startScreenTexture` nel file.

## RenderUtils.h

Per ridurre porzioni di codice duplicato sono stati aggiunti helper in `Progetto/Tappa_14/RenderUtils.h` e adottati in `main.cpp`:

- `applyFrontTextureIfAny(Card&, TextureManager&)`
	- Se la carta ha `originalTexturePath` assegna la texture frontale e imposta il rect completo.
- `applyBackTexture(Card&, const std::unordered_map<TextureKey, sf::Texture*>&)`
	- Applica la texture del retro (`CardBack`) e imposta il rect completo.
- `placeCentered(Card&, slotPos, slotSize, scaleX=1, scaleY=1)`
	- Centra la carta nello slot con dimensioni in scala.
- `placeRotatedDefense(Card&, slotPos, slotSize, thickness=0.60, length=0.95)`
	- Layout orizzontale per posizione di difesa: ruota 90° e centra nello slot.
- `setUpright(Card&)`
	- Resetta la carta “in piedi” (rotazione 0, origine default).
- `rotate180Centered(Card&, topLeft, size)`
	- Ruota 180° e centra nell’area (usata per la mano del P2).

Applicazioni principali in `main.cpp`:
- All'interno della funzione syncMonsterZoneToField P1/P2: centratura slot con `placeCentered`; difesa/FD con `placeRotatedDefense`; in piedi P1 con `setUpright`; P2 in piedi con `rotate180Centered`.
- All'interno della funzione syncSpellTrapZones: centratura con `placeCentered` (scale 0.70 e 0.78).
- Cimitero (top card preview): `placeCentered` con scala 0.75.
- Mano P2: `applyBackTexture` + `rotate180Centered`.

Queste utility non cambiano la logica di gioco, ma riducono linee e ripetizioni nel `main.cpp` mantenendo lo stesso comportamento visivo.

### Costanti e utilità aggiuntive in RenderUtils

Per migliorare la leggibilità e sostituire "magic numbers" ricorrenti sono state aggiunte:

- Costanti di scala degli slot:
	- `RenderUtils::FieldScale` (0.75) per le carte Mostro in piedi.
	- `RenderUtils::STScale` (0.70) per Magie/Trappole.
	- `RenderUtils::FieldSpellScale` (0.78) per la carta Terreno.
- Utility grafiche:
	- `mixColors(sf::Color a, sf::Color b, float t)` per fondere due colori (usata per effetti di tint).
	- `drawAttackDot(sf::RenderTarget&, const sf::Vector2f& pos, float radius, sf::Color color)` per disegnare il pallino che indica l'attacco.

Queste funzioni sono già adottate in `main.cpp` per sostituire calcoli inline ripetuti e valori hardcoded.

### Nota sul calcolo degli slot Mostri (refactor minimo)

Era stato tentato un helper generico per deduplicare l'individuazione di indice/posizione degli slot Mostro; è stato rimosso per evitare dipendenze incrociate e differenze di ownership dei puntatori. Il `main.cpp` ora usa una logica locale, semplice e chiara, che mantiene il comportamento invariato:

```cpp
int slotIdx = game->getMonsterSlotIndexAt(side, i);
if (slotIdx < 0) slotIdx = static_cast<int>(i);
sf::Vector2f slotPos = field.getSlotPosition
(
    Type::Monster,
    side == 0 ? P1 : P2,
    slotIdx
);    
```

Questo approccio evita di esporre tipi interni in header di utilità, mantiene il codice di rendering snello e non introduce regressioni.


## Aggiornamenti successivi

Per ridurre ulteriormente la duplicazione e mantenere il refactor “mini”, ho creato tre helper all'interno di `RenderUtils.h` come funzioni di rendering riutilizzabili:

- `RenderUtils::drawSpellTrapRow(window, cards, (function) isFaceDownAtIndex, texMap)`
- `RenderUtils::drawFieldSpellOpt(window, optionalCard)`
- `RenderUtils::drawTopCardAt(window, topCard, slotPos, slotSize, textureManager, scale)`

Questi sostituiscono i blocchi duplicati P1/P2. Esempi d’uso in `main.cpp`:

- ST P1: `RenderUtils::drawSpellTrapRow(window, p1STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(0,i); }, tex);`
- ST P2: `RenderUtils::drawSpellTrapRow(window, p2STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(1,i); }, tex);`
- FieldSpell P1/P2: `RenderUtils::drawFieldSpellOpt(window, p1FieldSpellCard);` / `RenderUtils::drawFieldSpellOpt(window, p2FieldSpellCard);`
- Cimitero P1/P2: costruzione opzionale della top e `RenderUtils::drawTopCardAt(...)` con `RenderUtils::FieldScale`.

### Bugfix visivo: centratura carte del P2

È stata corretta la centratura delle carte del giocatore 2 quando ruotate a 180°. La funzione `RenderUtils::rotate180Centered` viene ora invocata con un top-left centrato e dimensioni scalate in base a `RenderUtils::FieldScale`, assicurando un allineamento coerente con P1.


### Overlay di rendering estratti

Per snellire ulteriormente il `main.cpp`, le porzioni di codice che disegnano overlay sono state estratte in funzioni di utilità in `RenderUtils.h`:

- `RenderUtils::drawGameOverOverlay(window, font, windowSize, titleStr)` per l’overlay di Game Over.

Questa linea guida può essere estesa facilmente ad altri overlay (es. prompt conferma ritorno alla Home, panel scelte deck-send) seguendo lo stesso approccio: passare solo i dati necessari al rendering, senza introdurre dipendenze da logica di gioco in `RenderUtils`.

Oltre al Game Over, sono stati estratti anche questi overlay riutilizzabili (già in uso in `main.cpp`):

- `RenderUtils::drawConfirmReturnHomeOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const sf::Vector2i& mousePos)`
	- Mostra il popup di conferma “Torna alla Home?” con evidenziazione hover in base al mouse.
	- Uso tipico:
		```cpp
		if (returnPopupActive) {
				RenderUtils::drawConfirmReturnHomeOverlay(window, detailFont, window.getSize(), sf::Mouse::getPosition(window));
		}
		```

- `RenderUtils::drawResponsePromptOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const std::vector<std::string>& items, size_t selectedIndex)`
	- Mostra un piccolo pannello di richiesta/risposta con elenco opzioni e voce selezionata evidenziata.
	- Uso tipico:
		```cpp
		if (responsePromptActive) {
				std::vector<std::string> items;
				// Popolare items con i nomi delle carte attivabili...
				RenderUtils::drawResponsePromptOverlay(window, detailFont, window.getSize(), items, responseSelected);
		}
		```

- `RenderUtils::drawDeckSendOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const std::vector<Card>& candidates, size_t selectedIndex, const sf::Vector2f& slotSize, TextureManager& textureManager, float scale = 0.7f, float pad = 12.f)`
	- Mostra una griglia di carte (candidati) con evidenziazione della selezionata e hint dei tasti; scala e padding personalizzabili.
	- Uso tipico:
		```cpp
		if (deckSendChoiceActive) {
				RenderUtils::drawDeckSendOverlay(window, detailFont, window.getSize(), deckSendCandidates, deckSendSelected, slotSize, textureManager);
		}
		```

Nota: tutti gli overlay ricevono solamente dati grafici (font, dimensioni finestra, input mouse, lista stringhe o carte) e non dipendono dalla logica di gioco.




### Helper aggiuntivi per snellire il main

Per ridurre ulteriore duplicazione nei loop di disegno e nei controlli di click, sono disponibili anche questi helper:

- `RenderUtils::drawMonsterCard(sf::RenderWindow& window, Card cardCopy, bool sideTop, const sf::Vector2f& slotPos, const sf::Vector2f& slotSize, bool isDefense, bool isFaceDown, bool isSelectedAttacker, bool showAttackDot, const std::unordered_map<TextureKey, sf::Texture*>& texMap)`
	- Unifica il rendering dei mostri P1/P2 (orientamento, coperta/difesa, evidenziazione selezione e pallino attacco).
	- Uso tipico (P1):
		```cpp
		bool isSel = selectedAttackerIndex && *selectedAttackerIndex==i && attackSelectionActive;
		sf::Vector2f slotPos = field.getSlotPosition(Type::Monster, P1, slotIdx);
		RenderUtils::drawMonsterCard(window, fieldCards[i], /*sideTop*/false, slotPos, slotSize, isDef, isFD, isSel, showDot, tex);
		```

- `RenderUtils::confirmReturnHomeHitTest(const sf::Vector2u& windowSize, const sf::Vector2i& mousePos) -> ConfirmHit { None, Yes, No }`
	- Centralizza l’hit-test dei pulsanti del popup “Torna alla Home?”.
	- Uso tipico:
		```cpp
		switch(RenderUtils::confirmReturnHomeHitTest(window.getSize(), sf::Mouse::getPosition(window))){
			case RenderUtils::ConfirmHit::Yes: /* conferma */ break;
			case RenderUtils::ConfirmHit::No:  /* annulla  */ break;
			default: break;
		}
		```

- `RenderUtils::deckSendHitIndex(const sf::Vector2u& windowSize, const sf::Vector2f& slotSize, size_t candidateCount, const sf::Vector2i& mousePos, float scale=0.7f, float pad=12.f, size_t cols=5) -> std::optional<size_t>`
	- Restituisce l’indice della carta cliccata nella griglia dell’overlay DeckSend in modo coerente con `drawDeckSendOverlay`.
	- Uso tipico:
		```cpp
		if (deckSendChoiceActive && mb->button == sf::Mouse::Left) {
			if (auto hit = RenderUtils::deckSendHitIndex(window.getSize(), slotSize, deckSendCandidates.size(), sf::Mouse::getPosition(window))) {
				deckSendSelected = *hit;
			}
		}
		```




