## Tappa 14

Questo step introduce un mini-refactor focalizzato sulla gestione centralizzata delle risorse (texture/font) e sulla pulizia di `main.cpp`.

## Modifiche principali

- Introdotta una configurazione centralizzata in `Config.h` per path risorse e accesso alle texture tramite chiavi simboliche.
- Rimosse dal `main.cpp` tutte le variabili locali per singola texture (es. `textureFlipped`, `homeScreenTexture`, ecc.).
- Tutti i punti che usavano quelle variabili ora accedono alle texture tramite mappa e chiavi (`TextureKey`).
- Uniformato l’utilizzo della texture del retro carta in tutte le sezioni (deck reset, draw, rendering coperto, ecc.).
- Aggiunta una utility robusta per caricare il font con fallback di sistema su Windows.

## Config.h

`Progetto/Tappa_14/Config.h` fornisce:

- Path centralizzati:
	- `resourceBase`, `texturePath`, `fontPath`, `cardsJsonPath`, `decksJsonPath`.
- Enum `TextureKey` con le chiavi per le principali texture dell’app:
	- `FieldBackground`, `MonsterText`, `SpellTrap`, `Deck`, `Graveyard`, `ExtraDeck`, `FieldSpell`, `CardBack`, `CardFrontNotSet`, `StartScreen`, `HomeScreen`, `DeckSelectionScreen`.
- `texturePathMap()` che mappa ogni `TextureKey` al file corrispondente.
- `buildTextureMap(TextureManager&)` che costruisce una mappa `TextureKey -> sf::Texture*` caricando le texture tramite `TextureManager`.
- `findTextureInMap(map, key)` per recuperare velocemente una `sf::Texture&` dalla mappa.
- `loadDetailFont(sf::Font&, const std::string&)` che carica il font principale e, se fallisce, tenta `C:/Windows/Fonts/calibri.ttf`.

Nota: è incluso `SFML/Graphics.hpp` in `Config.h` per tipizzare correttamente le texture e il font.

## main.cpp

`Progetto/Tappa_14/main.cpp` è stato semplificato:

- All’avvio viene costruita una mappa texture con:
	- `auto tex = AppConfig::buildTextureMap(textureManager);`
- Le texture sono reperite on-demand con:
	- `AppConfig::findTextureInMap(tex, AppConfig::TextureKey::<Chiave>)`.
- Aggiornati i punti principali:
	- `ResourceManager::initialize(...)` usa `CardBack` via mappa.
	- Reset posizioni deck: `Deck::resetDeckCardPositions(..., CardBack)`.
	- `HomePage`, `DeckSelectionScreen` e `FieldLoadingAnimation` ricevono le texture tramite `findTextureInMap`.
	- Rendering carte coperte (P1/P2 e mano P2) usa sempre `CardBack` via mappa.
	- Start screen: `drawStartScreen(..., StartScreen, ...)` recuperata via mappa.
- Niente più variabili come `textureFlipped`, `homeScreenTexture`, `fieldTexture`, `startScreenTexture` nel file.

## RenderUtils.h

Per ridurre porzioni di codice duplicato sono stati aggiunti helper in `Progetto/Tappa_14/RenderUtils.h` e adottati in `main.cpp`:

- `applyFrontTextureIfAny(Card&, TextureManager&)`
	- Se la carta ha `originalTexturePath` assegna la texture frontale e imposta il rect completo.
- `applyBackTexture(Card&, const std::unordered_map<TextureKey, sf::Texture*>&)`
	- Applica la texture del retro (`CardBack`) e imposta il rect completo.
- `placeCentered(Card&, slotPos, slotSize, scaleX=1, scaleY=1)`
	- Centra la carta nello slot con dimensioni in scala.
- `placeRotatedDefense(Card&, slotPos, slotSize, thickness=0.60, length=0.95)`
	- Layout orizzontale per posizione di difesa: ruota 90° e centra nello slot.
- `setUpright(Card&)`
	- Resetta la carta “in piedi” (rotazione 0, origine default).
- `rotate180Centered(Card&, topLeft, size)`
	- Ruota 180° e centra nell’area (usata per la mano del P2).

Applicazioni principali in `main.cpp`:
- All'interno della funzione syncMonsterZoneToField P1/P2: centratura slot con `placeCentered`; difesa/FD con `placeRotatedDefense`; in piedi P1 con `setUpright`; P2 in piedi con `rotate180Centered`.
- All'interno della funzione syncSpellTrapZones: centratura con `placeCentered` (scale 0.70 e 0.78).
- Cimitero (top card preview): `placeCentered` con scala 0.75.
- Mano P2: `applyBackTexture` + `rotate180Centered`.

Queste utility non cambiano la logica di gioco, ma riducono linee e ripetizioni nel `main.cpp` mantenendo lo stesso comportamento visivo.

### Costanti e utilità aggiuntive in RenderUtils

Per migliorare la leggibilità e sostituire "magic numbers" ricorrenti sono state aggiunte:

- Costanti di scala degli slot:
	- `RenderUtils::FieldScale` (0.75) per le carte Mostro in piedi.
	- `RenderUtils::STScale` (0.70) per Magie/Trappole.
	- `RenderUtils::FieldSpellScale` (0.78) per la carta Terreno.
- Utility grafiche:
	- `mixColors(sf::Color a, sf::Color b, float t)` per fondere due colori (usata per effetti di tint).
	- `drawAttackDot(sf::RenderTarget&, const sf::Vector2f& pos, float radius, sf::Color color)` per disegnare il pallino che indica l'attacco.

Queste funzioni sono già adottate in `main.cpp` per sostituire calcoli inline ripetuti e valori hardcoded.

### Nota sul calcolo degli slot Mostri (refactor minimo)

Era stato tentato un helper generico per deduplicare l'individuazione di indice/posizione degli slot Mostro; è stato rimosso per evitare dipendenze incrociate e differenze di ownership dei puntatori. Il `main.cpp` ora usa una logica locale, semplice e chiara, che mantiene il comportamento invariato:

```cpp
int slotIdx = game->getMonsterSlotIndexAt(side, i);
if (slotIdx < 0) slotIdx = static_cast<int>(i);
sf::Vector2f slotPos = field.getSlotPosition(Type::Monster,
																						 side == 0 ? P1 : P2,
																						 slotIdx);
```

Questo approccio evita di esporre tipi interni in header di utilità, mantiene il codice di rendering snello e non introduce regressioni.


## Aggiornamenti successivi

Per ridurre ulteriormente la duplicazione e mantenere il refactor “mini”, ho creato tre helper inizialmente locali sono stati spostati in `RenderUtils.h` come funzioni di rendering riutilizzabili:

- `RenderUtils::drawSpellTrapRow(window, cards, isFaceDownAtIndex, texMap)`
- `RenderUtils::drawFieldSpellOpt(window, optionalCard)`
- `RenderUtils::drawTopCardAt(window, topCard, slotPos, slotSize, textureManager, scale)`

Questi sostituiscono i blocchi duplicati P1/P2. Esempi d’uso in `main.cpp`:

- ST P1: `RenderUtils::drawSpellTrapRow(window, p1STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(0,i); }, tex);`
- ST P2: `RenderUtils::drawSpellTrapRow(window, p2STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(1,i); }, tex);`
- FieldSpell P1/P2: `RenderUtils::drawFieldSpellOpt(window, p1FieldSpellCard);` / `RenderUtils::drawFieldSpellOpt(window, p2FieldSpellCard);`
- Cimitero P1/P2: costruzione opzionale della top e `RenderUtils::drawTopCardAt(...)` con `RenderUtils::FieldScale`.

### Bugfix visivo: centratura carte del P2

È stata corretta la centratura delle carte del giocatore 2 quando ruotate a 180°. La funzione `RenderUtils::rotate180Centered` viene ora invocata con un top-left centrato e dimensioni scalate in base a `RenderUtils::FieldScale`, assicurando un allineamento coerente con P1.




