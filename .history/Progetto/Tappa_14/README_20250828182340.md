## Tappa 14

Questo step introduce un mini-refactor focalizzato sulla gestione centralizzata delle risorse (texture/font) e sulla pulizia di `main.cpp`.

## Modifiche principali

- Introdotta una configurazione centralizzata in `Config.h` per path risorse e accesso alle texture tramite chiavi simboliche.
- Rimosse dal `main.cpp` tutte le variabili locali per singola texture (es. `textureFlipped`, `homeScreenTexture`, ecc.).
- Tutti i punti che usavano quelle variabili ora accedono alle texture tramite mappa e chiavi (`TextureKey`).
- Uniformato l’utilizzo della texture del retro carta in tutte le sezioni (deck reset, draw, rendering coperto, ecc.).
- Aggiunta una utility robusta per caricare il font con fallback di sistema su Windows.


## Config.h

`Progetto/Tappa_14/Config.h` fornisce:

- Path centralizzati:
	- `resourceBase`, `texturePath`, `fontPath`, `cardsJsonPath`, `decksJsonPath`.
- Enum `TextureKey` con le chiavi per le principali texture dell’app:
	- `FieldBackground`, `MonsterText`, `SpellTrap`, `Deck`, `Graveyard`, `ExtraDeck`, `FieldSpell`, `CardBack`, `CardFrontNotSet`, `StartScreen`, `HomeScreen`, `DeckSelectionScreen`.
- `texturePathMap()` che mappa ogni `TextureKey` al file corrispondente.
- `buildTextureMap(TextureManager&)` che costruisce una mappa `TextureKey -> sf::Texture*` caricando le texture tramite `TextureManager`.
- `findTextureInMap(map, key)` per recuperare velocemente una `sf::Texture&` dalla mappa.
- `loadDetailFont(sf::Font&, const std::string&)` che carica il font principale e, se fallisce, tenta `C:/Windows/Fonts/calibri.ttf`.

### Nuove costanti centralizzate (Timing e UI)

Oltre alle metriche già presenti, sono state introdotte ulteriori costanti per rimuovere numeri magici e rendere più coerente la configurazione:

- AppConfig::Timing
	- `FadeInFastSec = 0.5f`
	- `FadeOutFastSec = 0.4f`
	- `BattleFeedbackSec = 2.0f`
	- `NoDeckWarningSec = 3.0f`
	- `NoDeckWarningFadeSec = 0.8f`

- AppConfig::Ui (aggiunte)
	- `DeckScaleFactor = 0.9f` (scala visiva dello stack del deck)
	- `DeckSendScale = 0.7f`, `DeckSendPad = 12.f`, `DeckSendCols = 5` (griglia overlay invio dal Deck)

## main.cpp

`Progetto/Tappa_14/main.cpp` è stato semplificato:

- All’avvio viene costruita una mappa texture con:
	- `auto tex = AppConfig::buildTextureMap(textureManager);`
- Le texture sono reperite on-demand con:
	- `AppConfig::findTextureInMap(tex, AppConfig::TextureKey::<Chiave>)`.
- Aggiornati i punti principali:
	- `ResourceManager::initialize(...)` usa `CardBack` via mappa.
	- Reset posizioni deck: `Deck::resetDeckCardPositions(..., CardBack)`.
	- `HomePage`, `DeckSelectionScreen` e `FieldLoadingAnimation` ricevono le texture tramite `findTextureInMap`.
	- Rendering carte coperte (P1/P2 e mano P2) usa sempre `CardBack` via mappa.
	- Start screen: `drawStartScreen(..., StartScreen, ...)` recuperata via mappa.
- Niente più variabili come `textureFlipped`, `homeScreenTexture`, `fieldTexture`, `startScreenTexture` nel file.

Inoltre ho introdotto una piccola lambda locale:

```cpp
auto updateHandLayout = [&](){
	if(handPtr){
		updateHandPositions(*handPtr, windowSize, cardSize, spacing, y, HAND_MAXSIZE);
	}
};
```

Questa sostituisce le ripetute chiamate a `updateHandPositions(...)` in molti punti (eventi turno, scarti, attivazioni/set di ST, ecc.).

**Utilizzo delle Costanti definite in Config**

`main.cpp` ora utilizza anche le nuove costanti centralizzate:

- Timing
	- `AppConfig::Timing::FadeInFastSec` / `FadeOutFastSec` per le animazioni di fade della Deck Selection.
	- `AppConfig::Timing::NoDeckWarningSec` e `NoDeckWarningFadeSec` per l’avviso “Nessun Deck selezionato”.
	- `AppConfig::Timing::BattleFeedbackSec` per la durata dei messaggi centrali di feedback in battaglia.
- UI
	- `AppConfig::Ui::DeckScaleFactor` per calcolare la dimensione delle carte nello stack dei Deck.
	- `AppConfig::Ui::DeckSendCols` per la navigazione a griglia dell’overlay “invio dal Deck”.
	- `AppConfig::Ui::DeckSendScale` e `DeckSendPad` per il rendering della griglia dell’overlay.
	- `AppConfig::Ui::HudSize` e `CenterFeedbackY` per il testo di feedback centrale (al posto di 22/70 fissi).

## Aggiunta di RenderUtils.h

Per ridurre porzioni di codice duplicato sono stati aggiunti helper in `Progetto/Tappa_14/RenderUtils.h` e adottati in `main.cpp`:

- `applyFrontTextureIfAny(Card&, TextureManager&)`
	- Se la carta ha `originalTexturePath` assegna la texture frontale e imposta il rect completo.
- `applyBackTexture(Card&, const std::unordered_map<TextureKey, sf::Texture*>&)`
	- Applica la texture del retro (`CardBack`) e imposta il rect completo.
- `placeCentered(Card&, slotPos, slotSize, scaleX=1, scaleY=1)`
	- Centra la carta nello slot con dimensioni in scala.
- `placeRotatedDefense(Card&, slotPos, slotSize, thickness=0.60, length=0.95)`
	- Layout orizzontale per posizione di difesa: ruota 90° e centra nello slot.
- `setUpright(Card&)`
	- Resetta la carta “in piedi” (rotazione 0, origine default).
- `rotate180Centered(Card&, topLeft, size)`
	- Ruota 180° e centra nell’area (usata per la mano del P2).

Applicazioni principali in `main.cpp`:
- All'interno della funzione syncMonsterZoneToField P1/P2: centratura slot con `placeCentered`; difesa/FD con `placeRotatedDefense`; in piedi P1 con `setUpright`; P2 in piedi con `rotate180Centered`.
- All'interno della funzione syncSpellTrapZones: centratura con `placeCentered` (scale 0.70 e 0.78).
- Cimitero (top card preview): `placeCentered` con scala 0.75.
- Mano P2: `applyBackTexture` + `rotate180Centered`.

Queste utility non cambiano la logica di gioco, ma riducono linee e ripetizioni nel `main.cpp` mantenendo lo stesso comportamento visivo.


Per migliorare la leggibilità e sostituire "magic numbers" ricorrenti sono state aggiunte:

- Costanti di scala degli slot:
	- `RenderUtils::FieldScale` (0.75) per le carte Mostro in piedi.
	- `RenderUtils::STScale` (0.70) per Magie/Trappole.
	- `RenderUtils::FieldSpellScale` (0.78) per la carta Terreno.
- Utility grafiche:
	- `mixColors(sf::Color a, sf::Color b, float t)` per fondere due colori (usata per effetti di tint).
	- `drawAttackDot(sf::RenderTarget&, const sf::Vector2f& pos, float radius, sf::Color color)` per disegnare il pallino che indica l'attacco.

Queste funzioni sono già adottate in `main.cpp` per sostituire calcoli inline ripetuti e valori hardcoded.


**Aggiunta di altri Helper:**

Per ridurre ulteriormente la duplicazione e mantenere il refactor “mini”, ho creato tre helper all'interno di `RenderUtils.h` come funzioni di rendering riutilizzabili:

- `RenderUtils::drawSpellTrapRow(window, cards, (function) isFaceDownAtIndex, texMap)`
- `RenderUtils::drawFieldSpellOpt(window, optionalCard)`
- `RenderUtils::drawTopCardAt(window, topCard, slotPos, slotSize, textureManager, scale)`

Questi sostituiscono i blocchi duplicati P1/P2. Esempi d’uso in `main.cpp`:

- ST P1: `RenderUtils::drawSpellTrapRow(window, p1STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(0,i); }, tex);`
- ST P2: `RenderUtils::drawSpellTrapRow(window, p2STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(1,i); }, tex);`
- FieldSpell P1/P2: `RenderUtils::drawFieldSpellOpt(window, p1FieldSpellCard);` / `RenderUtils::drawFieldSpellOpt(window, p2FieldSpellCard);`
- Cimitero P1/P2: costruzione opzionale della top e `RenderUtils::drawTopCardAt(...)` con `RenderUtils::FieldScale`.


**Overlay di rendering estratti**

Per snellire ulteriormente il `main.cpp`, le porzioni di codice che disegnano overlay sono state estratte in funzioni di utilità in `RenderUtils.h`:

- `RenderUtils::drawGameOverOverlay(window, font, windowSize, titleStr)` per l’overlay di Game Over.

Questa linea guida può essere estesa facilmente ad altri overlay (es. prompt conferma ritorno alla Home, panel scelte deck-send) seguendo lo stesso approccio: passare solo i dati necessari al rendering, senza introdurre dipendenze da logica di gioco in `RenderUtils`.

Oltre al Game Over, sono stati estratti anche questi overlay riutilizzabili (già in uso in `main.cpp`):

- `RenderUtils::drawConfirmReturnHomeOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const sf::Vector2i& mousePos)`
	- Mostra il popup di conferma “Torna alla Home?” con evidenziazione hover in base al mouse.
	- Uso tipico:
		```cpp
		if (returnPopupActive) {
				RenderUtils::drawConfirmReturnHomeOverlay(window, detailFont, window.getSize(), sf::Mouse::getPosition(window));
		}
		```

- `RenderUtils::drawResponsePromptOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const std::vector<std::string>& items, size_t selectedIndex)`
	- Mostra un piccolo pannello di richiesta/risposta con elenco opzioni e voce selezionata evidenziata.
	- Uso tipico:
		```cpp
		if (responsePromptActive) {
				std::vector<std::string> items;
				// Popolare items con i nomi delle carte attivabili...
				RenderUtils::drawResponsePromptOverlay(window, detailFont, window.getSize(), items, responseSelected);
		}
		```

- `RenderUtils::drawDeckSendOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const std::vector<Card>& candidates, size_t selectedIndex, const sf::Vector2f& slotSize, TextureManager& textureManager, float scale = 0.7f, float pad = 12.f)`
	- Mostra una griglia di carte (candidati) con evidenziazione della selezionata e hint dei tasti; scala e padding personalizzabili.
	- Uso tipico:
		```cpp
		if (deckSendChoiceActive) {
				RenderUtils::drawDeckSendOverlay(window, detailFont, window.getSize(), deckSendCandidates, deckSendSelected, slotSize, textureManager);
		}
		```

Nota: tutti gli overlay ricevono solamente dati grafici (font, dimensioni finestra, input mouse, lista stringhe o carte) e non dipendono dalla logica di gioco.

Per ridurre ulteriore duplicazione nei loop di disegno e nei controlli di click, sono disponibili anche questi helper:

- `RenderUtils::drawMonsterCard(sf::RenderWindow& window, Card cardCopy, bool sideTop, const sf::Vector2f& slotPos, const sf::Vector2f& slotSize, bool isDefense, bool isFaceDown, bool isSelectedAttacker, bool showAttackDot, const std::unordered_map<TextureKey, sf::Texture*>& texMap)`
	- Unifica il rendering dei mostri P1/P2 (orientamento, coperta/difesa, evidenziazione selezione e pallino attacco).
	- Uso tipico (P1):
		```cpp
		bool isSel = selectedAttackerIndex && *selectedAttackerIndex==i && attackSelectionActive;
		sf::Vector2f slotPos = field.getSlotPosition(Type::Monster, P1, slotIdx);
		RenderUtils::drawMonsterCard(window, fieldCards[i], /*sideTop*/false, slotPos, slotSize, isDef, isFD, isSel, showDot, tex);
		```

- `RenderUtils::confirmReturnHomeHitTest(const sf::Vector2u& windowSize, const sf::Vector2i& mousePos) -> ConfirmHit { None, Yes, No }`
	- Centralizza l’hit-test dei pulsanti del popup “Torna alla Home?”.
	- Uso tipico:
		```cpp
		switch(RenderUtils::confirmReturnHomeHitTest(window.getSize(), sf::Mouse::getPosition(window))){
			case RenderUtils::ConfirmHit::Yes: /* conferma */ break;
			case RenderUtils::ConfirmHit::No:  /* annulla  */ break;
			default: break;
		}
		```

- `RenderUtils::deckSendHitIndex(const sf::Vector2u& windowSize, const sf::Vector2f& slotSize, size_t candidateCount, const sf::Vector2i& mousePos, float scale=0.7f, float pad=12.f, size_t cols=5) -> std::optional<size_t>`
	- Restituisce l’indice della carta cliccata nella griglia dell’overlay DeckSend in modo coerente con `drawDeckSendOverlay`.
	- Uso tipico:
		```cpp
		if (deckSendChoiceActive && mb->button == sf::Mouse::Left) {
			if (auto hit = RenderUtils::deckSendHitIndex(window.getSize(), slotSize, deckSendCandidates.size(), sf::Mouse::getPosition(window))) {
				deckSendSelected = *hit;
			}
		}
		```

	Inoltre, per le mani dei giocatori:

	- `RenderUtils::drawPlayerHand(sf::RenderWindow& window, const std::vector<Card>& hand, bool ssChoiceActive)`
		- Disegna la mano del player in basso applicando l’offset di “sollevamento” della carta selezionata.
	- `RenderUtils::drawOpponentHand(sf::RenderWindow& window, const std::vector<Card>& hand, const sf::Vector2u& windowSize, const sf::Vector2f& cardSize, float spacing, const std::unordered_map<TextureKey, sf::Texture*>& texMap, float topMargin=AppConfig::Ui::OpponentHandTopMarginPx)`
		- Disegna la mano dell’avversario in alto sempre coperta e ruotata 180°.



## HUD e messaggi a schermo (nuovo)

Per snellire ulteriormente `main.cpp`, l’HUD e i messaggi ricorrenti sono stati estratti in semplici funzioni di rendering in `RenderUtils.h` (nessuna logica di gioco, solo disegno testo):

- `RenderUtils::drawTopLeftHud(window, font, text, pos = {15,10}, charSize = 22)`
	- Disegna la riga informativa principale (turno, player, fase, carte in mano, GY) in alto a sinistra.
- `RenderUtils::drawLpHud(window, font, windowSize, lpCur, lpOpp, charSize = 22)`
	- Mostra gli LP in alto a destra (allineati a destra con padding costante).
- `RenderUtils::drawTributePrompt(window, font)`
	- Prompt “Seleziona tributi (ESC annulla)”.
- `RenderUtils::drawHandOverflowWarn(window, font)`
	- Avviso di mano oltre il limite che verrà scartata in End Phase.
- `RenderUtils::drawSSChoicePrompt(window, font)`
	- Prompt scelta Evocazione Speciale: “A = Attacco, D = Difesa (mai coperto)”.
- `RenderUtils::drawSTChoicePrompt(window, font)`
	- Prompt scelta Magia/Trappola: “A = Attiva, S = Setta”.
- `RenderUtils::drawBattleHint(window, font)`
	- Hint per la Battle Phase in alto a sinistra.
- `RenderUtils::drawCenterFeedback(window, font, windowSize, text, charSize = 22, y = 70.f)`
	- Messaggio effimero centrato (es. “Attacco dichiarato”).

Esempio d’uso (estratto da `main.cpp`):

```cpp
std::string hud = /* turno, player, fase, hand, gy */;
RenderUtils::drawTopLeftHud(window, detailFont, hud);
RenderUtils::drawLpHud(window, detailFont, window.getSize(), lpCur, lpOpp);

if (selectingTributes) RenderUtils::drawTributePrompt(window, detailFont);
if (over > 0)       RenderUtils::drawHandOverflowWarn(window, detailFont);
if (ssChoiceActive) RenderUtils::drawSSChoicePrompt(window, detailFont);
if (chooseActivateOrSetST) RenderUtils::drawSTChoicePrompt(window, detailFont);
if (game->getTurn().getPhase() == GamePhase::Battle) RenderUtils::drawBattleHint(window, detailFont);

if (!battleFeedbackMsg.empty())
		RenderUtils::drawCenterFeedback(window, detailFont, window.getSize(), battleFeedbackMsg, 22, 70.f);
```

Queste utility mantengono coerente lo stile dell’HUD (colori, contorni, posizioni) e riducono duplicazione nel `main.cpp`.

### UI metrics centralizzate (nuovo)

Sono state aggiunte piccole costanti per l’HUD in `AppConfig::Ui` (in `Config.h`) per evitare numeri magici sparsi:

- `PadLeft=15`, `TopY=10`, `WarnY=38`, `TribY=66`, `SSChoiceY=94`, `STChoiceY=122`, `CenterFeedbackY=70`
- `HudSize=22`, `SmallSize=20`

Gli HUD helpers le utilizzano di default; se servono posizioni personalizzate, puoi sempre passarle come parametri opzionali.

Ulteriori metriche ora centralizzate in `AppConfig::Ui` per rimuovere "magic numbers" dal `main.cpp`:

- `HandSpacingPx` (spaziatura mano P1)
- `HandBottomMarginPx` (margine basso mano P1)
- `OpponentHandTopMarginPx` (margine alto mano P2; usato anche come default in `RenderUtils::drawOpponentHand`)
- `DragThresholdPx` (soglia pixel per avviare il drag)
- `CardLiftPx` e `LiftSpeedPxPerSec` (offset e velocità del sollevamento carta selezionata in mano)
- `DetailsScrollStepPx` (passo scroll per pannelli dettagli)
- `OverlayHoldMs` (riservato per hold overlay)

Pannelli dettagli (nuovo):

- `DetailsPanelPosX`, `DetailsPanelPosY`, `DetailsPanelWidth`, `DetailsPanelHeight` (pannello dettagli carta selezionata/pescata)
- `OverlayDetailsPosXFactor`, `OverlayDetailsPosYFactor`, `OverlayDetailsWidth`, `OverlayDetailsHeight` (pannello dettagli quando è attivo un overlay Extra/Cimitero)

Il `main.cpp` ora usa queste costanti invece di valori fissi (400/150 e 340x260), mantenendo lo stile e facilitando future regolazioni.

Il `main.cpp` è stato aggiornato per usare queste costanti (spaziatura mano, margini, soglia drag, lift, scroll step). In particolare, il margine della mano dell'avversario è ora coerente con l'uso in animazioni (30px).

### syncZones wrapper (nuovo)

Nel `main.cpp` è stata introdotta una piccola lambda `syncZones()` che chiama entrambe:

```cpp
auto syncZones = [&](){
	syncMonsterZoneToField();
	syncSpellTrapZones();
};
```
Sostituisce le chiamate duplicate nei vari handler/eventi, mantenendo la logica invariata e riducendo ripetizioni.



### inputBlocked helper (nuovo)

È stato aggiunto in `main.cpp` un piccolo helper per centralizzare le condizioni che bloccano l'input utente durante overlay/prompts modali:

```
auto inputBlocked = [&](){
	return selectingTributes || ssChoiceActive || responsePromptActive || deckSendChoiceActive || returnPopupActive || gameOverActive;
};
```

Utilizzato per ridurre condizioni duplicate all'interno degli if.






