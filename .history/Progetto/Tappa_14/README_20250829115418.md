## Tappa 14

Questo step introduce un mini-refactor focalizzato sulla gestione centralizzata delle risorse (texture/font) e sulla pulizia di `main.cpp`.

## Modifiche principali

- Introdotta una configurazione centralizzata in `Config.h` per path risorse e accesso alle texture tramite chiavi simboliche.
- Rimosse dal `main.cpp` tutte le variabili locali per singola texture (es. `textureFlipped`, `homeScreenTexture`, ecc.).
- Tutti i punti che usavano quelle variabili ora accedono alle texture tramite mappa e chiavi (`TextureKey`).
- Uniformato l’utilizzo della texture del retro carta in tutte le sezioni (deck reset, draw, rendering coperto, ecc.).
- Aggiunta una utility robusta per caricare il font con fallback di sistema su Windows.


## Config.h

`Progetto/Tappa_14/Config.h` fornisce:

- Path centralizzati:
	- `resourceBase`, `texturePath`, `fontPath`, `cardsJsonPath`, `decksJsonPath`.
- Enum `TextureKey` con le chiavi per le principali texture dell’app:
	- `FieldBackground`, `MonsterText`, `SpellTrap`, `Deck`, `Graveyard`, `ExtraDeck`, `FieldSpell`, `CardBack`, `CardFrontNotSet`, `StartScreen`, `HomeScreen`, `DeckSelectionScreen`.
- `texturePathMap()` che mappa ogni `TextureKey` al file corrispondente.
- `buildTextureMap(TextureManager&)` che costruisce una mappa `TextureKey -> sf::Texture*` caricando le texture tramite `TextureManager`.
- `findTextureInMap(map, key)` per recuperare velocemente una `sf::Texture&` dalla mappa.
- `loadDetailFont(sf::Font&, const std::string&)` che carica il font principale e, se fallisce, tenta `C:/Windows/Fonts/calibri.ttf`.

### Nuove costanti centralizzate (Timing e UI)

Oltre alle metriche già presenti, sono state introdotte ulteriori costanti per rimuovere numeri magici e rendere più coerente la configurazione:

- AppConfig::Timing
	- `FadeInFastSec = 0.5f`
	- `FadeOutFastSec = 0.4f`
	- `BattleFeedbackSec = 2.0f`
	- `NoDeckWarningSec = 3.0f`
	- `NoDeckWarningFadeSec = 0.8f`

- AppConfig::Ui (aggiunte)
	- `DeckScaleFactor = 0.9f` (scala visiva dello stack del deck)
	- `DeckSendScale = 0.7f`, `DeckSendPad = 12.f`, `DeckSendCols = 5` (griglia overlay invio dal Deck)

## main.cpp

`Progetto/Tappa_14/main.cpp` è stato semplificato:

- All’avvio viene costruita una mappa texture con:
	- `auto tex = AppConfig::buildTextureMap(textureManager);`
- Le texture sono reperite on-demand con:
	- `AppConfig::findTextureInMap(tex, AppConfig::TextureKey::<Chiave>)`.
- Aggiornati i punti principali:
	- `ResourceManager::initialize(...)` usa `CardBack` via mappa.
	- Reset posizioni deck: `Deck::resetDeckCardPositions(..., CardBack)`.
	- `HomePage`, `DeckSelectionScreen` e `FieldLoadingAnimation` ricevono le texture tramite `findTextureInMap`.
	- Rendering carte coperte (P1/P2 e mano P2) usa sempre `CardBack` via mappa.
	- Start screen: `drawStartScreen(..., StartScreen, ...)` recuperata via mappa.
- Niente più variabili come `textureFlipped`, `homeScreenTexture`, `fieldTexture`, `startScreenTexture` nel file.

Inoltre ho introdotto una piccola lambda locale:

```cpp
auto updateHandLayout = [&](){
	if(handPtr){
		updateHandPositions(*handPtr, windowSize, cardSize, spacing, y, HAND_MAXSIZE);
	}
};
```

Questa sostituisce le ripetute chiamate a `updateHandPositions(...)` in molti punti (eventi turno, scarti, attivazioni/set di ST, ecc.).

**Utilizzo delle Costanti definite in Config**

`main.cpp` ora utilizza anche le nuove costanti centralizzate:

- Timing
	- `AppConfig::Timing::FadeInFastSec` / `FadeOutFastSec` per le animazioni di fade della Deck Selection.
	- `AppConfig::Timing::NoDeckWarningSec` e `NoDeckWarningFadeSec` per l’avviso “Nessun Deck selezionato”.
	- `AppConfig::Timing::BattleFeedbackSec` per la durata dei messaggi centrali di feedback in battaglia.
- UI
	- `AppConfig::Ui::DeckScaleFactor` per calcolare la dimensione delle carte nello stack dei Deck.
	- `AppConfig::Ui::DeckSendCols` per la navigazione a griglia dell’overlay “invio dal Deck”.
	- `AppConfig::Ui::DeckSendScale` e `DeckSendPad` per il rendering della griglia dell’overlay.
	- `AppConfig::Ui::HudSize` e `CenterFeedbackY` per il testo di feedback centrale (al posto di 22/70 fissi).

## Aggiunta di RenderUtils.h

Per ridurre porzioni di codice duplicato sono stati aggiunti helper in `Progetto/Tappa_14/RenderUtils.h` e adottati in `main.cpp`:

- `applyFrontTextureIfAny(Card&, TextureManager&)`
	- Se la carta ha `originalTexturePath` assegna la texture frontale e imposta il rect completo.
- `applyBackTexture(Card&, const std::unordered_map<TextureKey, sf::Texture*>&)`
	- Applica la texture del retro (`CardBack`) e imposta il rect completo.
- `placeCentered(Card&, slotPos, slotSize, scaleX=1, scaleY=1)`
	- Centra la carta nello slot con dimensioni in scala.
- `placeRotatedDefense(Card&, slotPos, slotSize, thickness=0.60, length=0.95)`
	- Layout orizzontale per posizione di difesa: ruota 90° e centra nello slot.
- `setUpright(Card&)`
	- Resetta la carta “in piedi” (rotazione 0, origine default).
- `rotate180Centered(Card&, topLeft, size)`
	- Ruota 180° e centra nell’area (usata per la mano del P2).

Applicazioni principali in `main.cpp`:
- All'interno della funzione syncMonsterZoneToField P1/P2: centratura slot con `placeCentered`; difesa/FD con `placeRotatedDefense`; in piedi P1 con `setUpright`; P2 in piedi con `rotate180Centered`.
- All'interno della funzione syncSpellTrapZones: centratura con `placeCentered` (scale 0.70 e 0.78).
- Cimitero (top card preview): `placeCentered` con scala 0.75.
- Mano P2: `applyBackTexture` + `rotate180Centered`.

Queste utility non cambiano la logica di gioco, ma riducono linee e ripetizioni nel `main.cpp` mantenendo lo stesso comportamento visivo.


Per migliorare la leggibilità e sostituire "magic numbers" ricorrenti sono state aggiunte:

- Costanti di scala degli slot:
	- `RenderUtils::FieldScale` (0.75) per le carte Mostro in piedi.
	- `RenderUtils::STScale` (0.70) per Magie/Trappole.
	- `RenderUtils::FieldSpellScale` (0.78) per la carta Terreno.
- Utility grafiche:
	- `mixColors(sf::Color a, sf::Color b, float t)` per fondere due colori (usata per effetti di tint).
	- `drawAttackDot(sf::RenderTarget&, const sf::Vector2f& pos, float radius, sf::Color color)` per disegnare il pallino che indica l'attacco.

Queste funzioni sono già adottate in `main.cpp` per sostituire calcoli inline ripetuti e valori hardcoded.


**Aggiunta di altri Helper:**

Per ridurre ulteriormente la duplicazione e mantenere il refactor “mini”, ho creato tre helper all'interno di `RenderUtils.h` come funzioni di rendering riutilizzabili:

- `RenderUtils::drawSpellTrapRow(window, cards, (function) isFaceDownAtIndex, texMap)`
- `RenderUtils::drawFieldSpellOpt(window, optionalCard)`
- `RenderUtils::drawTopCardAt(window, topCard, slotPos, slotSize, textureManager, scale)`

Questi sostituiscono i blocchi duplicati P1/P2. Esempi d’uso in `main.cpp`:

- ST P1: `RenderUtils::drawSpellTrapRow(window, p1STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(0,i); }, tex);`
- ST P2: `RenderUtils::drawSpellTrapRow(window, p2STCards, [&](size_t i){ return game && game->isSpellTrapFaceDownAt(1,i); }, tex);`
- FieldSpell P1/P2: `RenderUtils::drawFieldSpellOpt(window, p1FieldSpellCard);` / `RenderUtils::drawFieldSpellOpt(window, p2FieldSpellCard);`
- Cimitero P1/P2: costruzione opzionale della top e `RenderUtils::drawTopCardAt(...)` con `RenderUtils::FieldScale`.


**Overlay di rendering estratti**

Per snellire ulteriormente il `main.cpp`, le porzioni di codice che disegnano overlay sono state estratte in funzioni di utilità in `RenderUtils.h`:

- `RenderUtils::drawGameOverOverlay(window, font, windowSize, titleStr)` per l’overlay di Game Over.

Questa linea guida può essere estesa facilmente ad altri overlay (es. prompt conferma ritorno alla Home, panel scelte deck-send) seguendo lo stesso approccio: passare solo i dati necessari al rendering, senza introdurre dipendenze da logica di gioco in `RenderUtils`.

Oltre al Game Over, sono stati estratti anche questi overlay riutilizzabili (già in uso in `main.cpp`):

- `RenderUtils::drawConfirmReturnHomeOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const sf::Vector2i& mousePos)`
	- Mostra il popup di conferma “Torna alla Home?” con evidenziazione hover in base al mouse.
	- Uso tipico:
		```cpp
		if (returnPopupActive) {
				RenderUtils::drawConfirmReturnHomeOverlay(window, detailFont, window.getSize(), sf::Mouse::getPosition(window));
		}
		```

- `RenderUtils::drawResponsePromptOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const std::vector<std::string>& items, size_t selectedIndex)`
	- Mostra un piccolo pannello di richiesta/risposta con elenco opzioni e voce selezionata evidenziata.
	- Uso tipico:
		```cpp
		if (responsePromptActive) {
				std::vector<std::string> items;
				// Popolare items con i nomi delle carte attivabili...
				RenderUtils::drawResponsePromptOverlay(window, detailFont, window.getSize(), items, responseSelected);
		}
		```

- `RenderUtils::drawDeckSendOverlay(sf::RenderWindow& window, const sf::Font& font, const sf::Vector2u& windowSize, const std::vector<Card>& candidates, size_t selectedIndex, const sf::Vector2f& slotSize, TextureManager& textureManager, float scale = 0.7f, float pad = 12.f)`
	- Mostra una griglia di carte (candidati) con evidenziazione della selezionata e hint dei tasti; scala e padding personalizzabili.
	- Uso tipico:
		```cpp
		if (deckSendChoiceActive) {
				RenderUtils::drawDeckSendOverlay(window, detailFont, window.getSize(), deckSendCandidates, deckSendSelected, slotSize, textureManager);
		}
		```

Nota: tutti gli overlay ricevono solamente dati grafici (font, dimensioni finestra, input mouse, lista stringhe o carte) e non dipendono dalla logica di gioco.

Per ridurre ulteriore duplicazione nei loop di disegno e nei controlli di click, sono disponibili anche questi helper:

- `RenderUtils::drawMonsterCard(sf::RenderWindow& window, Card cardCopy, bool sideTop, const sf::Vector2f& slotPos, const sf::Vector2f& slotSize, bool isDefense, bool isFaceDown, bool isSelectedAttacker, bool showAttackDot, const std::unordered_map<TextureKey, sf::Texture*>& texMap)`
	- Unifica il rendering dei mostri P1/P2 (orientamento, coperta/difesa, evidenziazione selezione e pallino attacco).
	- Uso tipico (P1):
		```cpp
		bool isSel = selectedAttackerIndex && *selectedAttackerIndex==i && attackSelectionActive;
		sf::Vector2f slotPos = field.getSlotPosition(Type::Monster, P1, slotIdx);
		RenderUtils::drawMonsterCard(window, fieldCards[i], /*sideTop*/false, slotPos, slotSize, isDef, isFD, isSel, showDot, tex);
		```

- `RenderUtils::confirmReturnHomeHitTest(const sf::Vector2u& windowSize, const sf::Vector2i& mousePos) -> ConfirmHit { None, Yes, No }`
	- Centralizza l’hit-test dei pulsanti del popup “Torna alla Home?”.
	- Uso tipico:
		```cpp
		switch(RenderUtils::confirmReturnHomeHitTest(window.getSize(), sf::Mouse::getPosition(window))){
			case RenderUtils::ConfirmHit::Yes: /* conferma */ break;
			case RenderUtils::ConfirmHit::No:  /* annulla  */ break;
			default: break;
		}
		```

- `RenderUtils::deckSendHitIndex(const sf::Vector2u& windowSize, const sf::Vector2f& slotSize, size_t candidateCount, const sf::Vector2i& mousePos, float scale=0.7f, float pad=12.f, size_t cols=5) -> std::optional<size_t>`
	- Restituisce l’indice della carta cliccata nella griglia dell’overlay DeckSend in modo coerente con `drawDeckSendOverlay`.
	- Uso tipico:
		```cpp
		if (deckSendChoiceActive && mb->button == sf::Mouse::Left) {
			if (auto hit = RenderUtils::deckSendHitIndex(window.getSize(), slotSize, deckSendCandidates.size(), sf::Mouse::getPosition(window))) {
				deckSendSelected = *hit;
			}
		}
		```

	Inoltre, per le mani dei giocatori:

	- `RenderUtils::drawPlayerHand(sf::RenderWindow& window, const std::vector<Card>& hand, bool ssChoiceActive)`
		- Disegna la mano del player in basso applicando l’offset di “sollevamento” della carta selezionata.
	- `RenderUtils::drawOpponentHand(sf::RenderWindow& window, const std::vector<Card>& hand, const sf::Vector2u& windowSize, const sf::Vector2f& cardSize, float spacing, const std::unordered_map<TextureKey, sf::Texture*>& texMap, float topMargin=AppConfig::Ui::OpponentHandTopMarginPx)`
		- Disegna la mano dell’avversario in alto sempre coperta e ruotata 180°.



## HUD e messaggi a schermo (nuovo)

Per snellire ulteriormente `main.cpp`, l’HUD e i messaggi ricorrenti sono stati estratti in semplici funzioni di rendering in `RenderUtils.h` (nessuna logica di gioco, solo disegno testo):

- `RenderUtils::drawTopLeftHud(window, font, text, pos = {15,10}, charSize = 22)`
	- Disegna la riga informativa principale (turno, player, fase, carte in mano, GY) in alto a sinistra.
- `RenderUtils::drawLpHud(window, font, windowSize, lpCur, lpOpp, charSize = 22)`
	- Mostra gli LP in alto a destra (allineati a destra con padding costante).
- `RenderUtils::drawTributePrompt(window, font)`
	- Prompt “Seleziona tributi (ESC annulla)”.
- `RenderUtils::drawHandOverflowWarn(window, font)`
	- Avviso di mano oltre il limite che verrà scartata in End Phase.
- `RenderUtils::drawSSChoicePrompt(window, font)`
	- Prompt scelta Evocazione Speciale: “A = Attacco, D = Difesa (mai coperto)”.
- `RenderUtils::drawSTChoicePrompt(window, font)`
	- Prompt scelta Magia/Trappola: “A = Attiva, S = Setta”.
- `RenderUtils::drawBattleHint(window, font)`
	- Hint per la Battle Phase in alto a sinistra.
- `RenderUtils::drawCenterFeedback(window, font, windowSize, text, charSize = 22, y = 70.f)`
	- Messaggio effimero centrato (es. “Attacco dichiarato”).

Esempio d’uso (estratto da `main.cpp`):

```cpp
std::string hud = /* turno, player, fase, hand, gy */;
RenderUtils::drawTopLeftHud(window, detailFont, hud);
RenderUtils::drawLpHud(window, detailFont, window.getSize(), lpCur, lpOpp);

if (selectingTributes) RenderUtils::drawTributePrompt(window, detailFont);
if (over > 0)       RenderUtils::drawHandOverflowWarn(window, detailFont);
if (ssChoiceActive) RenderUtils::drawSSChoicePrompt(window, detailFont);
if (chooseActivateOrSetST) RenderUtils::drawSTChoicePrompt(window, detailFont);
if (game->getTurn().getPhase() == GamePhase::Battle) RenderUtils::drawBattleHint(window, detailFont);

if (!battleFeedbackMsg.empty())
		RenderUtils::drawCenterFeedback(window, detailFont, window.getSize(), battleFeedbackMsg, 22, 70.f);
```

Queste utility mantengono coerente lo stile dell’HUD (colori, contorni, posizioni) e riducono duplicazione nel `main.cpp`.

### UI metrics centralizzate (nuovo)

Sono state aggiunte piccole costanti per l’HUD in `AppConfig::Ui` (in `Config.h`) per evitare numeri magici sparsi:

- `PadLeft=15`, `TopY=10`, `WarnY=38`, `TribY=66`, `SSChoiceY=94`, `STChoiceY=122`, `CenterFeedbackY=70`
- `HudSize=22`, `SmallSize=20`

Gli HUD helpers le utilizzano di default; se servono posizioni personalizzate, puoi sempre passarle come parametri opzionali.

Ulteriori metriche ora centralizzate in `AppConfig::Ui` per rimuovere "magic numbers" dal `main.cpp`:

- `HandSpacingPx` (spaziatura mano P1)
- `HandBottomMarginPx` (margine basso mano P1)
- `OpponentHandTopMarginPx` (margine alto mano P2; usato anche come default in `RenderUtils::drawOpponentHand`)
- `DragThresholdPx` (soglia pixel per avviare il drag)
- `CardLiftPx` e `LiftSpeedPxPerSec` (offset e velocità del sollevamento carta selezionata in mano)
- `DetailsScrollStepPx` (passo scroll per pannelli dettagli)
- `OverlayHoldMs` (riservato per hold overlay)

Pannelli dettagli (nuovo):

- `DetailsPanelPosX`, `DetailsPanelPosY`, `DetailsPanelWidth`, `DetailsPanelHeight` (pannello dettagli carta selezionata/pescata)
- `OverlayDetailsPosXFactor`, `OverlayDetailsPosYFactor`, `OverlayDetailsWidth`, `OverlayDetailsHeight` (pannello dettagli quando è attivo un overlay Extra/Cimitero)

Il `main.cpp` ora usa queste costanti invece di valori fissi (400/150 e 340x260), mantenendo lo stile e facilitando future regolazioni.

Il `main.cpp` è stato aggiornato per usare queste costanti (spaziatura mano, margini, soglia drag, lift, scroll step). In particolare, il margine della mano dell'avversario è ora coerente con l'uso in animazioni (30px).

### syncZones wrapper (nuovo)

Nel `main.cpp` è stata introdotta una piccola lambda `syncZones()` che chiama entrambe:

```cpp
auto syncZones = [&](){
	syncMonsterZoneToField();
	syncSpellTrapZones();
};
```
Sostituisce le chiamate duplicate nei vari handler/eventi, mantenendo la logica invariata e riducendo ripetizioni.

### inputBlocked helper (nuovo)

È stato aggiunto in `main.cpp` un piccolo helper per centralizzare le condizioni che bloccano l'input utente durante overlay/prompts modali:

```
auto inputBlocked = [&](){
	return selectingTributes || ssChoiceActive || responsePromptActive || deckSendChoiceActive || returnPopupActive || gameOverActive;
};
```

Utilizzato per ridurre condizioni duplicate all'interno degli if.



### Gestione Input estratta

È stato introdotto `Progetto/Tappa_14/InputController.{h,cpp}` per centralizzare alcuni rami di gestione input e alleggerire il `main.cpp`.

Attualmente il Controller gestisce:
- Chiusura finestra (evento `Closed`).
- Overlay Game Over: tasti Space/Enter/Escape per tornare alla Home e reset partita.
- Popup conferma ritorno: tasti Y/N/Escape/Space e click sui pulsanti tramite hit-test in `RenderUtils`.
- Start Screen: Enter per andare alla Home.
- Deck Selection: ESC o click destro per avviare il fade-out.
- Overlay DeckSend: click sinistro per selezionare la carta nella griglia; frecce Sinistra/Destra/Su/Giù per navigare; Enter per confermare; ESC per annullare.
- Battle: click destro per scegliere il bersaglio avversario (con messaggio di feedback).
- Battle: tasto A per attacco diretto (selezionato un attaccante e nessun bersaglio), con feedback.
- In gioco: Space apre il popup "Torna alla Home" (spostato dal main al controller).
- Tasti centralizzati (come N) ora gestiti direttamente nel Controller, non più via callback dal main:
	- N: avanza fase, apre prompt risposta se presente, resetta tributi fuori dalle Main, abilita UI battaglia in Battle.
	- T: se non sei in End Phase, salta a End; se già in End e consentito, chiude il turno.
	- O: aggiunge un mostro dummy al campo avversario per test e riallinea la UI.
- Prompt di risposta (Trap/Quick) nel turno avversario: frecce Su/Giù (o Sinistra/Destra) per navigare; Enter per confermare; ESC per chiudere.
- ESC globale (fuori DeckSelection): deseleziona carta, chiude overlay Extra/Cimitero, cancella selezione tributi/pending scelte, ripristina carta in mano e resync zone.

 In aggiunta, il Controller ora intercetta anche la pressione/rilascio del mouse per la logica di hold degli overlay Extra/Cimitero, riducendo ulteriormente il codice nel `main.cpp`.

**Nuovi Aggiornamenti (controller + overlay)**

- Spostata nel Controller la gestione dell'hold sugli slot Extra/Cimitero: pressione lunga per aprire l'overlay relativo, mantenimento finché il tasto è premuto, chiusura con rilascio o ESC.
- Il `main.cpp`, oltre ai precedenti parametri, passa al `Input::Context` i riferimenti agli overlay (`extraOverlay`, `graveyardOverlay`), le posizioni slot (`extraDeckSlotPos`, `graveyardSlotPos`) e i data provider (`getExtraCards()`, `getGraveyardCards()`).
- ESC globale già chiude entrambi gli overlay e ripristina lo stato d'interazione.
- Cleanup: la pressione/rilascio mouse per overlay è nel Controller; non servono più richiami duplicati nel `main.cpp`.
- Fix grafico: mano del giocatore in alto (P2) centrata correttamente e sempre in copertura (retro + rotazione 180°) tramite `RenderUtils::drawOpponentHand`.
- Rimosso dal `main.cpp` il codice duplicato che gestiva i tasti e i flussi ora centralizzati in `InputController` (C, X, E/P, A/S e la navigazione del prompt). Questo rende il `main` più leggero e delega tutte le interazioni correlate all'input al controller.
- Il `InputController` contiene implementazioni conservative per E/P (evoca/posiziona) e A/S (attiva/setta ST) e utilizza le API `Game::try*` e `activateSetSpellTrapFor`; in caso di rollback richiama i callback forniti dal `main` (`restoreCardAtHandIndex`, `syncSpellTrapZones`, `syncMonsterZoneToField`).
- Dopo la modifica è stata eseguita una build di verifica del target `mainTappa14` (compilazione OK).


### InputController (estrazione gestione input)

Per ridurre ulteriormente la complessità di `main.cpp`, una prima trancheho spostato gli eventi in una nuova classe `InputController`:

In questo modo il main risulta un po' più leggibile.

Nota aggiuntiva: nelle modifiche più recenti il `InputController` gestisce anche i tasti C e X e le scelte modali E/P e A/S (vedi sotto):

- C: toggle della posizione del mostro selezionato sul campo (chiama `Game::togglePosition`).
- X: attivazione di una Magia/Trappola settata sotto il mouse (hit-test sulle `p1STCards`, chiama `Game::activateSetSpellTrap` e poi `syncSpellTrapZones` se presente).
- E/P: durante la scelta Evoca/Posiziona dalla mano il controller ora gestisce i tasti E (Evoca) e P (Posiziona). Le chiamate usano le API conservative (`tryNormalSummon` / `tryNormalSet`) e, in caso di fallimento, ripristinano la carta in mano tramite il callback fornito dal `main`.
- A/S: durante la scelta Attiva/Set per Magie/Trappole il controller gestisce A (Attiva) e S (Setta); usa le API esistenti (`activateSetSpellTrapFor` / `tryNormalSet`) e richiama `syncSpellTrapZones` dopo attivazioni.

Queste operazioni richiedono che il `main.cpp` fornisca al `Input::Context` alcuni riferimenti/utility (già aggiunti): `p1STCards` (per l'hit-test), `syncSpellTrapZones` (per riallineare la UI dopo attivazioni) e `findMonsterSlotIndexUnderMouse` (per eventuali versioni future che evocano/posizionano su slot target). Il comportamento attuale è volutamente conservativo per mantenere la logica di gioco invariata.
La classe controller contiene come campo un elemento state di tipo Contex. Contex è una struct composta da tutti i flag e le funzioni che servono per gestire gli eventi. Cerco di spostare all'interno di InputController unicamente quegli eventi il quale spostamento non va ad inficiare troppo sulla modifica del codice. (Il codice resta analogo, semplicemente è spostato per essere un po' più ordinato) 

- File: `Progetto/Tappa_14/InputController.h/.cpp`
- Sposta la gestione di eventi generali e modali, tra cui:
	- Chiusura finestra, Game Over (Space/Enter/Escape)
	- Popup “Torna alla Home?” (Y/N/Esc/Space e click su Yes/No con hit-test centralizzato in `RenderUtils`)
	- Avvio dalla Start Screen (Enter)
	- Deck Selection: ESC o tasto destro per fade-out
	- Overlay DeckSend: click sinistro su una cella della griglia (hit-test centralizzato)
	- Battle: click destro per scegliere il bersaglio tra i mostri avversari

Uso minimale in `main.cpp`:

1) Creare un contex con i riferimenti necessari (finestra, stato, flag overlay, callback `resetMatch`, predicato `inputBlocked`, schermate/overlay interessati, getter di `Game*`).
2) Istanziate `Input::Controller controller(ctx);`
3) Nel poll degli eventi, delegare: `if (controller.handleEvent(event)) continue;`


**Aggiornamenti successivi (refactor e fix)**

- Mapping dei tasti SFML
	- Aggiunto `SFMLCompat.h` che contiene al suo interno un mapping di `M_MOUSE_*` e `M_KEY_*` --> per comodità

- InputController: aggiunti nuovi eventi e bugfix
	- `Progetto/Tappa_14/InputController.{h,cpp}` è stato esteso: ora gestisce tutti i flussi modali precedentemente in `main.cpp` e alcuni fix funzionali.
	- Fix per il flusso A/S (Attiva / Set):
		- `A` (attiva dalla mano) ora invoca correttamente `Game::activateSpellFromHand(handIdx)` quando appropriato (comportamento allineato a prima del refactor).
		- `S` (set) distingue nettamente tra Set di Spell/Trap e Set di Mostri:
			- per Spell/Trap viene chiamata `Game::setSpellOrTrap(...)`.
			- per Mostri viene chiamata `Game::tryNormalSet(...)`.
		- In entrambi i casi i gli aggiornamenti UI vengono gestiti tramite i callback forniti in `Input::Context` (`restoreCardAtHandIndex`, `syncSpellTrapZones`, `syncMonsterZoneToField`).

- Wiring e callback aggiuntivi
	- Aggiunta la callback `updateHandLayout` in `Input::Context` e wiring corrispondente in `main.cpp` (lambda `updateHandLayout` che chiama `updateHandPositions(...)`).
	- L'ordine di inizializzazione dei parametri in `main.cpp` è stato corretto per rispettare l'ordine dei membri di `Input::Context`.

	## Modifiche recenti (delta)

	Questa sezione riepiloga le ultime piccole patch e fix applicati dopo l'ultimo aggiornamento principale del refactor.

	- EventDispatcher: aggiunta la possibilità di unsubscribe esplicito (metodo `unsubscribe(int)`), utile per evitare callback pendenti quando un oggetto si distrugge o quando si smonta il gioco.
	- AppHandlers: estratta la logica di registrazione agli eventi di `Game` in `AppHandlers.h/.cpp` con funzioni `attachGameHandlers(...)` e `detachGameHandlers(...)`. Ora il `main` chiama `detachGameHandlers` prima di `game.reset()` per rimuovere le sottoscrizioni attive.
	- CMake: il target `mainTappa14` è stato aggiornato per includere la nuova sorgente `AppHandlers.cpp` (build verificata).
	- DrawAnimation: il costruttore ora memorizza un flag `skipCenterReveal` passato alla creazione; questo permette alle animazioni di ricordare che quella pescata non deve mostrare la carta al centro (es. pescata dell'avversario).
	- DrawController: al termine di un'animazione di pesca viene preparata una `finalCard` che viene inserita nella mano garantendo che la texture finale sia corretta:
		- se la pescata è stata contrassegnata come "skip reveal" la carta finale riceve esplicitamente la texture del retro;
		- altrimenti viene riapplicata la texture frontale con `RenderUtils::applyFrontTextureIfAny` prima di pushare nella mano.
		Questo risolve casi intermittenti in cui carte arrivate in mano mantenevano la texture del retro.
	- Debug: aggiunte stampe di tracing in `DrawController` per loggare quando una pescata viene messa in coda e quale texture (FRONT/BACK) è stata assegnata alla `finalCard` al termine dell'animazione. I messaggi sono del tipo:
		- `[DrawController] queued draw; forceSkipReveal=0/1 remaining=N`
		- `[DrawController] finalCard applied FRONT texture for card origPath='...'`
		- `[DrawController] finalCard assigned BACK texture for card origPath='...'`


- RenderUtils e UI
	- `RenderUtils.h` è stato arricchito con ulteriori helper grafici e ora include il supporto necessario per centrare/ruotare la mano dell'avversario, overlay e hit-test (già descritti nelle sezioni sopra).
	- Fix visivo: mano del giocatore 2 ora sempre centrata e resa in copertura con rotazione 180°.


### Ultimi aggiornamenti (refactor di `main.cpp` e pulizia callback)

- Introdotte tre funzioni helper locali in `main.cpp`:
	- `registerDefaultEffects(Game&)` — centralizza la registrazione degli effetti/attivazioni usati nei demo-game (es. WhiteStone, Reliquario del Drago, Pianto di Argento).
	- `createGameAndAttachResources(...)` — costruisce l'istanza `Game`, attacca `DrawController` e l'`external deck`, registra gli effetti e azzera le cache UI (ST, FieldSpell). Usata per sostituire due blocchi duplicati che inizializzavano il gioco (Home->Gioca e DeckSelection).
	- `setupAppHandlers(...)` — popola `AppHandlers::Context` (hoisted) e chiama `AppHandlers::attachGameHandlers` oltre a installare callback comuni come il `discardCallback` e `setHandLimit`.

- Riduzione del boilerplate di callback in `main.cpp`:
	- Il popolamento di `appHandlersCtx` era ripetuto inline in più punti: ora viene fatto da `setupAppHandlers(...)` in un unico posto, riducendo le lambda duplicate e migliorando la leggibilità.
	- Alcuni callback ripetitivi (es. `updateHandLayout`, `syncZones`) sono stati ricompattati come lambda locali e passati al helper.

- Piccolo miglioramento di build/ordine delle funzioni:
	- Per consentire la chiamata a `setupAppHandlers` prima della sua definizione è stata aggiunta una forward-declaration locale in cima a `main.cpp`. Questo è un cambiamento minimale che evita errori di compilazione dovuti all'ordering senza cambiare il layout logico del file.

- Verifica rapida:
	- Le parti modificate sono strettamente locali a `Progetto/Tappa_14/main.cpp` e ad `AppHandlers` (già presente nella sezione "Modifiche recenti"). Dopo le modifiche è stata eseguita una build di verifica del target `mainTappa14` per assicurare che non siano stati introdotti errori di compilazione.

Questi cambiamenti non alterano la logica di gioco: servono esclusivamente a centralizzare l'inizializzazione, consolidare i callback e ridurre duplicazione nel file principale.


## Nuovo File, GameWiring.h e .cpp

Questa sezione elenca le modifiche applicate nell'ultima serie di patch (29 agosto 2025), utili per chi vuole capire i cambiamenti recenti o testare rapidamente la build.

- Spostate tre helper principali da `main.cpp` in un nuovo modulo `Progetto/Tappa_14/GameWiring.{h,cpp}`:
	- `registerDefaultEffects(Game&)`
	- `createGameAndAttachResources(...)`
	- `setupAppHandlers(...)` (popola `AppHandlers::Context` e chiama `AppHandlers::attachGameHandlers`).

- Fix include: corretto l'include per `DiscardController` in `GameWiring.cpp` per usare il percorso consolidato `GameLogic/DiscardController/DiscardController.h`.

- Rimosso duplicato: eliminata la definizione statica duplicata di `setupAppHandlers` in `main.cpp` per evitare simboli duplicati al link.

- Aggiornato `CMakeLists.txt` per includere il nuovo file sorgente di wiring nel target `mainTappa14` e build verificata in Release.

- Esito build: la ricostruzione di `mainTappa14` è stata eseguita con esito positivo (nessun errore di link/compilazione dopo le correzioni).




